<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>PIE</title>
<style>
body {
	background-color: rgb(240,255,255); /* Azure */
	font-family: verdana;
	font-size: 10pt;
}
input, select {
	font-family: verdana;
	font-size: 10pt;
	margin-top: 2px;
	margin-bottom: 2px;
}
#progressDiv, #failedDiv {
	background-color: rgb(230,230,250); /* Lavender */
	border: 2px solid black;
	border-radius: 10px;
	display: none;
	font-size: 14pt;
	text-align: center;
	padding: 10px;
	position: absolute;
}
#failedDiv {
	padding-bottom: 4px;
}
#progressText {
	position: relative;
	top: -10px;
	padding-right: 12px;
}
@keyframes spinDiscAnimation {
	from { transform: rotateZ(0deg); }
	to { transform: rotateZ(360deg); }
}
#spinDisc {
	display: inline-block;
	width: 0px;
	height: 0px;

	border-top: 20px solid rgb(65,105,225); /* RoyalBlue */
	border-left: 20px solid rgb(135,206,250); /* LightSkyBlue */
	border-bottom: 20px solid rgb(65,105,225); /* RoyalBlue */
	border-right: 20px solid rgb(135,206,250); /* LightSkyBlue */
	border-radius: 20px;

	animation-name: spinDiscAnimation;
	animation-duration: 1.5s;
	animation-iteration-count: infinite;
	animation-timing-function: linear;
	animation-play-state: paused;
}
#filterCodeDiv {
	background-color: rgb(230,230,250); /* Lavender */
	border: 2px solid black;
	border-radius: 10px;
	display: none;
	padding: 6px 10px 4px 10px; /* top right bottom left */
	position: absolute;
}
code {
	background-color: rgb(245,245,220); /* Beige */
	border-radius: 10px;
	display: block;
	overflow: scroll;
	padding: 4px;
	white-space: pre;
}
#cssCode, #urlCode {
	margin-bottom: 4px;
}
#copyCSS, #copySVG, #copyURL {
	background-color: rgb(245,222,179); /* Wheat */
	border-radius: 6px;
	float: right;
	font-size: 8pt;
	padding: 1px 4px 1px 4px;
	text-transform: uppercase;
}
.cT { color: rgb(0,100,0); } /* DarkGreen */
.cA { color: rgb(128,0,128); } /* Purple */
.cV { color: rgb(0,0,128); } /* Navy */
#controlDiv {
	background-color: rgba(230,230,250,0.8);
	border: 2px solid black;
	border-radius: 10px;
	text-align: center;
	width: 520px;
	padding: 2px;
	position: absolute;
	left: 52px;
	top: 422px;
}
#photoDiv {
	position: relative;
	overflow: hidden;
	width: 600px;
	height: 400px;
	border: 4px solid black;
}
#photo {
	position: absolute;
	left: 0px;
	top: 0px;
	width: 600px;
	height: 400px;
}
#cropper {
	position: absolute;
	width: 596px; /* 600 with the border */
	height: 396px; /* 400 with the border */
	top: 12px;
	left: 12px;
	border: 2px dashed black;
	box-shadow: 0px 0px 4px 3px rgba(255,255,255,.5); /* offset-x offset-y blur-radius spread-radius color */
	cursor: move;
}
#resizeNW {
	position: absolute;
	width: 20px;
	height: 20px;
	top: -10px;
	left: -10px;
	cursor: nw-resize;
}
#resizeNE {
	position: absolute;
	width: 20px;
	height: 20px;
	top: -10px;
	right: -10px;
	cursor: ne-resize;
}
#resizeSW {
	position: absolute;
	width: 20px;
	height: 20px;
	bottom: -10px;
	left: -10px;
	cursor: sw-resize;
}
#resizeSE {
	position: absolute;
	width: 20px;
	height: 20px;
	bottom: -10px;
	right: -10px;
	cursor: se-resize;
}
a {
	text-decoration: none;
}
a:hover {
	color: rgb(218,69,0);
}
#filterDiv table {
	margin-left: auto;
	margin-right: auto;
	border-collapse: collapse;
}
#filterDiv td {
	padding-left: 4px;
	padding-right: 4px;
	text-align: left;
}
#filterDiv select:first-child {
	vertical-align: middle;
}
.uiDiv {
	display: inline-block;
}
.uiDiv select {
	margin-top: 0px;
}
.uiDivBlur {
	vertical-align: top;
}
.uiDivBlur input[type="text"] {
	margin-top: 0px;
	margin-bottom: 0px;
}
.uiDivPolar {
	padding: 3px 0px 0px 4px; /* top right bottom left */
	vertical-align: top;
}
.uiDivConvolve select {
	margin-top: 2px;
	margin-left: 2px;
}
.ui1 {
}
.ui2 {
	background-color: rgba(240,240,250,0.9);
	border-color: rgb(200,200,220);
	border-width: 1px;
	border-style: solid;
}
.clickable {
	font-size: 12pt;
	padding-left: 2px;
	padding-right: 2px;
	text-align: center;
}
.clickable:hover {
	background-color: rgb(136,136,136);
	color: rgb(255,255,255);
	cursor: pointer;
}
#fileBrowser {
	display: none;
}
input[type="range"] {
	margin: 0px 2px 0px 2px; /* top right bottom left */
	vertical-align: middle;
	width: 180px;
}
#canvas {
	border: 4px solid black;
	display: none;
	position: absolute;
}
#downloadLink {
	display: none;
}
.channelOn {
	border-style: inset;
	border-width: 1px;
	cursor: pointer;
	padding: 2px;
	vertical-align: middle;
}
.channelOff {
	background-color: rgb(230,230,230);
	border-style: outset;
	border-width: 1px;
	color: rgb(160,160,160);
	cursor: pointer;
	padding: 2px;
	vertical-align: middle;
}
.channelR {
	background-color: rgb(255,0,0); /* Red */
	color: rgb(255,192,203); /* Pink */
}
.channelR:hover {
	background-color: rgb(255,192,203); /* Pink */
	color: rgb(255,0,0); /* Red */
}
.channelG {
	background-color: rgb(0,128,0); /* Green */
	color: rgb(124,252,0); /* LawnGreen */
}
.channelG:hover {
	background-color: rgb(124,252,0); /* LawnGreen */
	color: rgb(0,128,0); /* Green */
}
.channelB {
	background-color: rgb(0,0,255); /* Blue */
	color: rgb(0,191,255); /* DeepSkyBlue */
}
.channelB:hover {
	background-color: rgb(0,191,255); /* DeepSkyBlue */
	color: rgb(0,0,255); /* Blue */
}
#cropGeometryDiv {
	display: none;
}
</style>
<script src="cropList.js"></script>
<script src="filter.js"></script>
<script>
var originalWidth;
var originalHeight;
var aspectX;
var aspectY;
var startX;
var startY;
var multiplyX;
var multiplyY;
var rotateAngle;
var photoLeft;
var photoTop;
var cropInverseAspectRatio;
var cropped = false;
var minWidth;
var maxWidth;
var minHeight;
var maxHeight;

var photo;
var cropper;
var photoMinX;
var photoMinY;
var photoMaxX;
var photoMaxY;
var divWidth;
var divHeight;
var cropXField;
var cropYField;
var cropWidthField;
var cropHeightField;
var cropWidth;
var cropHeight;
var photoScale;
var cropperLeft;
var cropperTop;
var cropperWidth;
var cropperHeight;
var controlDiv;

var imagePath;
var imageNames;
var imageFiles;
var filters = [];
var filterIndex = {};
var queryString;
var copySupported = true;
var showCropGeometry;

var downloadBlobURL = true;      // if true, create a blob: URL / if false, create a data: URL
var downloadLink;                // the HTML <a> element for the Save link
var downloadLinkReady = false;   // only used if downloadBlobURL is true
var downloadURL = null;          // only used if downloadBlobURL is true
var downloadQuality = 0.92;
var downloadType = "image/jpeg";

function releaseElement()
{
	document.onmousemove = null;
	document.onmouseup = null;
}
function photoDrag(event)
{
	var x = startX + event.clientX;
	var y = startY + event.clientY;

	var scaleX = divWidth / cropWidth;
	var scaleY = divHeight / cropHeight;

	var dW = (originalWidth - cropWidth) * scaleX;
	var dH = (originalHeight - cropHeight) * scaleY;

	var photoMinLeft = -dW;
	var photoMaxLeft = 0;
	var photoMinTop = -dH;
	var photoMaxTop = 0;

	if (rotateAngle === 90) {
		photoMinLeft = 0;
		photoMaxLeft = dH;
		photoMinTop = -dW;
		photoMaxTop = 0;
	} else if (rotateAngle === 180) {
		photoMinLeft = 0;
		photoMaxLeft = dW;
		photoMinTop = 0;
		photoMaxTop = dH;
	} else if (rotateAngle === 270) {
		photoMinLeft = -dH;
		photoMaxLeft = 0;
		photoMinTop = 0;
		photoMaxTop = dW;
	}

	if (x > photoMaxLeft) x = photoMaxLeft;
	else if (x < photoMinLeft) x = photoMinLeft;
	if (y > photoMaxTop) y = photoMaxTop;
	else if (y < photoMinTop) y = photoMinTop;

	photo.style.left = x + 'px';
	photo.style.top = y + 'px';

	var x2 = Math.round(x / scaleX);
	var y2 = Math.round(y / scaleY);
	if (rotateAngle === 0) {
		photoLeft = x;
		photoTop = y;
		cropXField.value = -x2;
		cropYField.value = -y2;
	} else if (rotateAngle === 90) {
		photoLeft = y;
		photoTop = -x;
		cropXField.value = -y2;
		cropYField.value = x2;
	} else if (rotateAngle === 180) {
		photoLeft = -x;
		photoTop = -y;
		cropXField.value = x2;
		cropYField.value = y2;
	} else if (rotateAngle === 270) {
		photoLeft = -y;
		photoTop = x;
		cropXField.value = y2;
		cropYField.value = -x2;
	}

	return false;
}
function startPhotoDrag(event)
{
	startX = photo.offsetLeft - event.clientX;
	startY = photo.offsetTop - event.clientY;
	document.onmousemove = photoDrag;
	document.onmouseup = releaseElement;
	return false;
}
function cropperDrag(event)
{
	var x = startX + event.clientX;
	var y = startY + event.clientY;
	if (x < photoMinX) x = photoMinX;
	if (y < photoMinY) y = photoMinY;
	var x2 = Math.round((x - photoMinX) * photoScale);
	var y2 = Math.round((y - photoMinY) * photoScale);
	var dW = originalWidth - cropWidth;
	var dH = originalHeight - cropHeight;
	if (rotateAngle === 0) {
		if (x2 > dW) x2 = dW;
		if (y2 > dH) y2 = dH;
		cropXField.value = x2;
		cropYField.value = y2;
	} else if (rotateAngle === 90) {
		if (x2 > dH) x2 = dH;
		if (y2 > dW) y2 = dW;
		cropXField.value = y2;
		cropYField.value = dH - x2;
	} else if (rotateAngle === 180) {
		if (x2 > dW) x2 = dW;
		if (y2 > dH) y2 = dH;
		cropXField.value = dW - x2;
		cropYField.value = dH - y2;
	} else if (rotateAngle === 270) {
		if (x2 > dH) x2 = dH;
		if (y2 > dW) y2 = dW;
		cropXField.value = dW - y2;
		cropYField.value = x2;
	}
	if (x + cropperWidth > photoMaxX) x = photoMaxX - cropperWidth;
	if (y + cropperHeight > photoMaxY) y = photoMaxY - cropperHeight;
	cropper.style.left = (cropperLeft = x) + 'px';
	cropper.style.top = (cropperTop = y) + 'px';
	return false;
}
function startCropperDrag(event)
{
	startX = cropperLeft - event.clientX;
	startY = cropperTop - event.clientY;
	document.onmousemove = cropperDrag;
	document.onmouseup = releaseElement;
	return false;
}
function dragResize(event)
{
	var dX = (event.clientX - startX) * multiplyX;
	var dY = (event.clientY - startY) * multiplyY;
	var absdX = Math.abs(dX);
	var absdY = Math.abs(dY);
	if (absdX < 2 && absdY < 2)
		return false;
	if (dX * dY <= 0)
	{
		startX = event.clientX;
		startY = event.clientY;
		return false;
	}

	var delta;
	var aspect;
	var cropDimension;
	var setCropDimension;

	if (absdX > absdY) {
		delta = dX;
		setCropDimension = (rotateAngle === 0 || rotateAngle === 180) ? setCropWidth : setCropHeight;
	} else {
		delta = dY;
		setCropDimension = (rotateAngle === 0 || rotateAngle === 180) ? setCropHeight : setCropWidth;
	}

	if (setCropDimension === setCropWidth) {
		aspect = aspectX;
		cropDimension = cropWidth;
	} else {
		aspect = aspectY;
		cropDimension = cropHeight;
	}

	delta = Math.trunc(2 * delta * photoScale / aspect) * aspect;
	if (delta === 0)
		return false;

	setCropDimension(cropDimension - delta);
	startX = event.clientX;
	startY = event.clientY;
	return false;
}
function startDragResize(event)
{
	event.stopPropagation();
	startX = event.clientX;
	startY = event.clientY;
	document.onmousemove = dragResize;
	document.onmouseup = releaseElement;
	return false;
}
function startDragResizeNW(event)
{
	multiplyX = 1;
	multiplyY = 1;
	return startDragResize(event);
}
function startDragResizeNE(event)
{
	multiplyX = -1;
	multiplyY = 1;
	return startDragResize(event);
}
function startDragResizeSE(event)
{
	multiplyX = -1;
	multiplyY = -1;
	return startDragResize(event);
}
function startDragResizeSW(event)
{
	multiplyX = 1;
	multiplyY = -1;
	return startDragResize(event);
}
function greatestCommonDivisor(a, b)
{
	while (b !== 0)
	{
		var remainder = a % b;
		a = b;
		b = remainder;
	}
	return a;
}
function setDisplayArea()
{
	var width = 900;
	var height = 600;

	if (originalWidth > originalHeight && width > height ||
		originalWidth < originalHeight && width < height)
	{
		divWidth = width;
		divHeight = height;
	} else {
		divWidth = height;
		divHeight = width;
	}

	if (divWidth > originalWidth)
		divWidth = originalWidth;
	if (divHeight > originalHeight)
		divHeight = originalHeight;

	if (divWidth / divHeight != originalWidth / originalHeight)
	{
		var m = Math.floor(divWidth / aspectX);
		if (m === 0)
			m = 1;
		divWidth = m * aspectX;
		divHeight = m * aspectY;
	}

	document.getElementById("divWidth").value = divWidth;
	document.getElementById("divHeight").value = divHeight;
	document.getElementById("aspectRatio").firstChild.nodeValue = '(' + aspectX + ':' + aspectY + ')';

	photoLeft = 0;
	photoTop = 0;
	photo.style.left = '0px';
	photo.style.top = '0px';
	photo.style.width = divWidth + 'px';
	photo.style.height = divHeight + 'px';
	photo.style.webkitTransform = null;
	photo.style.transform = null;
	photo.style.cursor = 'default';
	photo.onmousedown = preventDefault;

	var photoDiv = document.getElementById("photoDiv");
	photoDiv.style.width = divWidth + 'px';
	photoDiv.style.height = divHeight + 'px';
	photoMinX = photoDiv.offsetLeft + 4;
	photoMinY = photoDiv.offsetTop + 4;
	photoMaxX = photoDiv.offsetLeft + photoDiv.offsetWidth - 4;
	photoMaxY = photoDiv.offsetTop + photoDiv.offsetHeight - 4;

	photoScale = originalWidth / divWidth;
	rotateAngle = 0;
	minWidth = divWidth;
	maxWidth = originalWidth;
	minHeight = divHeight;
	maxHeight = originalHeight;
}
function init()
{
	var gcd = greatestCommonDivisor(originalWidth, originalHeight);
	aspectX = originalWidth / gcd;
	aspectY = originalHeight / gcd;
	cropInverseAspectRatio = false;

	setDisplayArea();
	disableCropElements(false);
	setInverseAspectRatioAbility();

	cropWidthField = document.getElementById("cropWidthField");
	cropHeightField = document.getElementById("cropHeightField");
	cropWidthField.value = cropWidth = Math.max(divWidth, originalWidth / 2);
	cropHeightField.value = cropHeight = Math.max(divHeight, originalHeight / 2);

	cropXField = document.getElementById("cropXField");
	cropYField = document.getElementById("cropYField");
	cropXField.value = (originalWidth - cropWidth) / 2;
	cropYField.value = (originalHeight - cropHeight) / 2;

	setCropperXY();
	cropperWidth = cropWidth / photoScale;
	cropperHeight = cropHeight / photoScale;
	cropper.style.width = (cropperWidth - 4) + 'px';
	cropper.style.height = (cropperHeight - 4) + 'px';
	cropper.onmousedown = startCropperDrag;

	document.getElementById("resizeNW").onmousedown = startDragResizeNW;
	document.getElementById("resizeNE").onmousedown = startDragResizeNE;
	document.getElementById("resizeSW").onmousedown = startDragResizeSW;
	document.getElementById("resizeSE").onmousedown = startDragResizeSE;

	if (document.getElementById("inverseAspectRatioCheckbox").checked)
		toggleInverseAspectRatio();
}
function setCropWidthAndHeight(width, height)
{
	var x = +cropXField.value + Math.floor(cropWidth / 2 - width / 2);
	var y = +cropYField.value + Math.floor(cropHeight / 2 - height / 2);

	if (x + width > originalWidth)
		x = originalWidth - width;
	else if (x < 0)
		x = 0;
	if (y + height > originalHeight)
		y = originalHeight - height;
	else if (y < 0)
		y = 0;

	cropXField.value = x;
	cropYField.value = y;
	cropWidthField.value = width;
	cropHeightField.value = height;
	cropWidth = width;
	cropHeight = height;

	width = Math.round(width / photoScale);
	height = Math.round(height / photoScale);
	if (rotateAngle === 0 || rotateAngle === 180) {
		cropperWidth = width;
		cropperHeight = height;
	} else {
		cropperWidth = height;
		cropperHeight = width;
	}
	cropper.style.width = (cropperWidth - 4) + 'px';
	cropper.style.height = (cropperHeight - 4) + 'px';
	setCropperXY();
}
function setCropWidth(width)
{
	if (width > maxWidth)
		width = maxWidth;
	else if (width < minWidth || isNaN(width))
		width = minWidth;

	width -= width % aspectX;
	setCropWidthAndHeight(width, width / aspectX * aspectY);
}
function setCropHeight(height)
{
	if (height > maxHeight)
		height = maxHeight;
	else if (height < minHeight || isNaN(height))
		height = minHeight;

	height -= height % aspectY;
	setCropWidthAndHeight(height / aspectY * aspectX, height);
}
function changeCropWidth()
{
	setCropWidth(+cropWidthField.value);
	if (cropped) crop();
}
function changeCropHeight()
{
	setCropHeight(+cropHeightField.value);
	if (cropped) crop();
}
function changeCropX()
{
	var x = +cropXField.value;

	if (x + cropWidth > originalWidth)
		x = originalWidth - cropWidth;
	else if (x < 0 || isNaN(x))
		x = 0;

	cropXField.value = x;
	setCropperXY();
	if (cropped) {
		photoLeft = -x * divWidth / cropWidth;
		if (rotateAngle === 0)
			photo.style.left = photoLeft + 'px';
		else if (rotateAngle === 90)
			photo.style.top = photoLeft + 'px';
		else if (rotateAngle === 180)
			photo.style.left = -photoLeft + 'px';
		else if (rotateAngle === 270)
			photo.style.top = -photoLeft + 'px';
		setSpecParam();
	}
}
function changeCropY()
{
	var y = +cropYField.value;

	if (y + cropHeight > originalHeight)
		y = originalHeight - cropHeight;
	else if (y < 0 || isNaN(y))
		y = 0;

	cropYField.value = y;
	setCropperXY();
	if (cropped) {
		photoTop = -y * divHeight / cropHeight;
		if (rotateAngle === 0)
			photo.style.top = photoTop + 'px';
		else if (rotateAngle === 90)
			photo.style.left = -photoTop + 'px';
		else if (rotateAngle === 180)
			photo.style.top = -photoTop + 'px';
		else if (rotateAngle === 270)
			photo.style.left = photoTop + 'px';
		setSpecParam();
	}
}
function setSpecParam()
{
	document.getElementById("cropGeometry").value = "('"
		+ document.getElementById("fileNameField").value + "', '"
		+ cropWidth + "x" + cropHeight + "+"
		+ cropXField.value + "+" + cropYField.value + "')";
}
function crop()
{
	if (cropInverseAspectRatio && !cropped) {
		turnPhotoDiv();
		var width = divWidth;
		var height = divHeight;
		divWidth = height;
		divHeight = width;
	}

	var scaleX = divWidth / cropWidth;
	var scaleY = divHeight / cropHeight;

	photoLeft = -cropXField.value * scaleX;
	photoTop = -cropYField.value * scaleY;
	photo.style.width = (originalWidth * scaleX) + 'px';
	photo.style.height = (originalHeight * scaleY) + 'px';

	transformPhoto();
	setSpecParam();

	cropped = true;
	cropper.style.display = 'none';
	photo.onmousedown = startPhotoDrag;
	photo.style.cursor = 'move';
}
function undo()
{
	if (cropInverseAspectRatio && cropped) {
		turnPhotoDiv();
		var width = divWidth;
		var height = divHeight;
		divWidth = height;
		divHeight = width;
	}

	photoLeft = 0;
	photoTop = 0;
	photo.style.width = divWidth + 'px';
	photo.style.height = divHeight + 'px';

	transformPhoto();
	setCropperXY();

	photo.onmousedown = preventDefault;
	photo.style.cursor = 'default';
	cropper.style.display = 'block';
	cropped = false;
}
function transformPhoto()
{
	var transform = null;
	var delta = (photo.offsetWidth - photo.offsetHeight) / 2;
	var dX = 0;
	var dY = 0;
	var left = photoLeft;
	var top = photoTop;

	if (rotateAngle === 90) {
		dX = delta;
		dY = delta + photo.offsetHeight - divHeight;
		left = -photoTop;
		top = photoLeft;
	} else if (rotateAngle === 180) {
		dX = photo.offsetWidth - divWidth;
		dY = photo.offsetHeight - divHeight;
		left = -photoLeft;
		top = -photoTop;
	} else if (rotateAngle === 270) {
		dX = -delta + photo.offsetWidth - divWidth;
		dY = -delta;
		left = photoTop;
		top = -photoLeft;
	}

	if (rotateAngle !== 0 || dX !== 0 || dY !== 0) {
		transform = "rotate(" + rotateAngle + "deg)";
		transform += " translate(" + dX + "px," + dY + "px)";
	}
	photo.style.webkitTransform = transform;
	photo.style.transform = transform;
	photo.style.left = left + 'px';
	photo.style.top = top + 'px';
}
function setCropperXY()
{
	var x = Math.round(cropXField.value / photoScale);
	var y = Math.round(cropYField.value / photoScale);
	if (rotateAngle === 0) {
		cropperLeft = photoMinX + x;
		cropperTop = photoMinY + y;
	} else if (rotateAngle === 90) {
		cropperLeft = photoMaxX - y - cropperWidth;
		cropperTop = photoMinY + x;
	} else if (rotateAngle === 180) {
		cropperLeft = photoMaxX - x - cropperWidth;
		cropperTop = photoMaxY - y - cropperHeight;
	} else if (rotateAngle === 270) {
		cropperLeft = photoMinX + y;
		cropperTop = photoMaxY - x - cropperHeight;
	}
	cropper.style.left = cropperLeft + 'px';
	cropper.style.top = cropperTop + 'px';
}
function turnPhotoDiv()
{
	var photoDiv = document.getElementById("photoDiv");
	var width = photoDiv.offsetWidth - 8;
	var height = photoDiv.offsetHeight - 8;
	photoDiv.style.width = height + 'px';
	photoDiv.style.height = width + 'px';
	photoMinX = photoDiv.offsetLeft + 4;
	photoMinY = photoDiv.offsetTop + 4;
	photoMaxX = photoDiv.offsetLeft + photoDiv.offsetWidth - 4;
	photoMaxY = photoDiv.offsetTop + photoDiv.offsetHeight - 4;
}
function rotatePhoto(angle)
{
	rotateAngle = (rotateAngle + angle) % 360;
	transformPhoto();
	var oldCropperLeft = cropperLeft - photoMinX;
	var oldCropperTop = cropperTop - photoMinY;
	if (angle === 90 || angle === 270) {
		turnPhotoDiv();
		swapXYFilters();
		var width = cropperWidth;
		var height = cropperHeight;
		cropperWidth = height;
		cropperHeight = width;
		cropper.style.width = (cropperWidth - 4) + 'px';
		cropper.style.height = (cropperHeight - 4) + 'px';
	}
	if (angle === 90) {
		cropperLeft = photoMaxX - oldCropperTop - cropperWidth;
		cropperTop = photoMinY + oldCropperLeft;
	} else if (angle === 180) {
		cropperLeft = photoMaxX - oldCropperLeft - cropperWidth;
		cropperTop = photoMaxY - oldCropperTop - cropperHeight;
	} else if (angle === 270) {
		cropperLeft = photoMinX + oldCropperTop;
		cropperTop = photoMaxY - oldCropperLeft - cropperHeight;
	}
	cropper.style.left = cropperLeft + 'px';
	cropper.style.top = cropperTop + 'px';
}
function setInverseAspectRatioAbility()
{
	var checkbox = document.getElementById("inverseAspectRatioCheckbox");

	if (originalWidth > originalHeight) {
		if (divWidth > originalHeight)
			checkbox.disabled = true;
	} else {
		if (divHeight > originalWidth)
			checkbox.disabled = true;
	}
	if (checkbox.disabled)
		checkbox.checked = false;
}
function toggleInverseAspectRatio()
{
	cropInverseAspectRatio = !cropInverseAspectRatio;

	if (cropInverseAspectRatio) {
		minWidth = divHeight;
		minHeight = divWidth;

		if (originalWidth > originalHeight) {
			maxWidth = Math.floor(originalHeight / aspectX * aspectY);
			maxHeight = originalHeight;
		} else {
			maxWidth = originalWidth;
			maxHeight = Math.floor(originalWidth / aspectY * aspectX);
		}
	} else {
		minWidth = divWidth;
		maxWidth = originalWidth;

		minHeight = divHeight;
		maxHeight = originalHeight;
	}

	var x = aspectX;
	var y = aspectY;
	aspectX = y;
	aspectY = x;

	if (originalWidth > originalHeight)
		setCropHeight(cropWidth);
	else
		setCropWidth(cropHeight);

	if (cropped) {
		turnPhotoDiv();
		var width = divWidth;
		var height = divHeight;
		divWidth = height;
		divHeight = width;
		crop();
	}
}
function controlDivDrag(event)
{
	controlDiv.style.left = (startX + event.clientX) + 'px';
	controlDiv.style.top = (startY + event.clientY) + 'px';
	return false;
}
function startControlDivDrag(event)
{
	if (event.target instanceof HTMLInputElement ||
		event.target instanceof HTMLSelectElement) return true;
	startX = controlDiv.offsetLeft - event.clientX;
	startY = controlDiv.offsetTop - event.clientY;
	document.onmousemove = controlDivDrag;
	document.onmouseup = releaseElement;
	return false;
}
function preventDefault(event)
{
	if (event.preventDefault) event.preventDefault();
}
function centerElement(element, top, left)
{
	if (top === null) {
		var displayHeight = document.documentElement.clientHeight;
		top = Math.round((displayHeight - element.clientHeight) / 2);
	}
	if (left === null) {
		var displayWidth = document.documentElement.clientWidth;
		left = Math.round((displayWidth - element.clientWidth) / 2);
	}
	element.style.top = top + "px";
	element.style.left = left + "px";
}
function showLoading(fileName)
{
	cropper.style.cursor = "wait";
	document.body.style.cursor = "wait";

	document.getElementById("spinDisc").style.animationPlayState = "running";

	var progressDiv = document.getElementById("progressDiv");
	progressDiv.style.left = "auto";
	progressDiv.firstChild.firstChild.nodeValue = "Loading " + fileName;
	progressDiv.style.display = "block";
	centerElement(progressDiv, 96, null);
}
function hideLoading()
{
	cropper.style.cursor = "move";
	document.body.style.cursor = "default";

	document.getElementById("progressDiv").style.display = "none";
	document.getElementById("spinDisc").style.animationPlayState = "paused";
}
function showFailed(errorMessage)
{
	var failedDiv = document.getElementById("failedDiv");
	failedDiv.style.left = "auto";
	failedDiv.firstChild.nodeValue = errorMessage;
	failedDiv.style.display = "block";
	centerElement(failedDiv, 22, null);
}
function hideFailed()
{
	document.getElementById("failedDiv").style.display = "none";
}
function imageLoaded(event)
{
	if (cropped) undo();

	var imageObject = event.target;
	photo.src = imageObject.src;
	originalWidth = imageObject.width;
	originalHeight = imageObject.height;

	if (imageFiles !== undefined)
		URL.revokeObjectURL(imageObject.src);

	init();
	hideLoading();

	if (queryString.overlayCanvas) {
		queryString.overlayCanvas = false;
		document.getElementById("overlayCanvasLink").click();
	}
}
function imageFailedLoad(event)
{
	hideLoading();

	var fileNameField = document.getElementById("fileNameField");
	var selectedIndex = fileNameField.selectedIndex;

	showFailed("Failed to load " + imageNames[selectedIndex]);

	if (imageNames.length > 1)
		imageNames.splice(selectedIndex, 1);
	else
		imageNames = undefined;

	fileNameField.remove(selectedIndex);
	loadImage();
}
function loadImage()
{
	var prevButton = document.getElementById("prevButton");
	var nextButton = document.getElementById("nextButton");
	if (imageNames === undefined)
	{
		prevButton.disabled = true;
		nextButton.disabled = true;
		downloadLink.style.display = "none";
		return;
	}
	var fileNameField = document.getElementById("fileNameField");
	if (fileNameField.options.length === 0)
	{
		for (var i = 0; i < imageNames.length; ++i)
			fileNameField.options[i] = new Option(imageNames[i], imageNames[i]);
		if (queryString.selectedImage > 0) {
			fileNameField.selectedIndex = queryString.selectedImage;
			queryString.selectedImage = 0;
		} else
			fileNameField.selectedIndex = 0;
	}
	var selectedIndex = fileNameField.selectedIndex;
	prevButton.disabled = (selectedIndex === 0);
	nextButton.disabled = (selectedIndex === fileNameField.options.length - 1);

	downloadLink.download = imageNames[selectedIndex];
	downloadLink.style.display = "inline";

	showLoading(imageNames[selectedIndex]);

	var imageObject = new Image();
	imageObject.addEventListener("load", imageLoaded, false);
	imageObject.addEventListener("error", imageFailedLoad, false);
	if (imageFiles === undefined)
		imageObject.src = imagePath + imageNames[selectedIndex];
	else
		imageObject.src = URL.createObjectURL(imageFiles[selectedIndex]);
}
function prevImage()
{
	var fileNameField = document.getElementById("fileNameField");
	if (fileNameField.selectedIndex > 0)
		--fileNameField.selectedIndex;
	loadImage();
}
function nextImage()
{
	var fileNameField = document.getElementById("fileNameField");
	if (fileNameField.selectedIndex < fileNameField.options.length - 1)
		++fileNameField.selectedIndex;
	loadImage();
}
function drawCanvas()
{
	if (photo.src === "") return null;

	var canvas = document.getElementById("canvas");

	if (rotateAngle === 0 || rotateAngle === 180) {
		canvas.width = divWidth;
		canvas.height = divHeight;
	} else {
		canvas.width = divHeight;
		canvas.height = divWidth;
	}

	var context = canvas.getContext("2d");

	if (rotateAngle === 0)
		context.setTransform(1, 0, 0, 1, 0, 0);
	else if (rotateAngle === 90)
		context.setTransform(0, 1, -1, 0, canvas.width, 0);
	else if (rotateAngle === 180)
		context.setTransform(-1, 0, 0, -1, canvas.width, canvas.height);
	else if (rotateAngle === 270)
		context.setTransform(0, -1, 1, 0, 0, canvas.height);

	if (cropped)
		context.drawImage(photo, +cropXField.value, +cropYField.value,
			cropWidth, cropHeight, 0, 0, divWidth, divHeight);
	else
		context.drawImage(photo, 0, 0, divWidth, divHeight);

	var imageData;
	try {
		imageData = context.getImageData(0, 0, canvas.width, canvas.height);
	} catch (exception) {
		if (exception instanceof DOMException && exception.name === 'SecurityError')
			showFailed(exception);
		else
			showFailed(exception);
		return null;
	}

	for (var filter of filters)
	{
		var option = filter.option;

		if (filter.value === option.noChangeValue || filter.channels === 0)
			continue;

		var amount = option.unit === '%' ? filter.value / 100 : filter.value;
		var info = option.ui.getInfo ? option.ui.getInfo(filter) : undefined;

		imageData = option.applyFilter(context, imageData, amount, filter.channels, info);
	}

	context.putImageData(imageData, 0, 0);
	return canvas;
}
function saveImage(event)
{
	if (downloadBlobURL) {
		if (downloadLinkReady) {
			downloadLinkReady = false;
			return;
		}
		if (downloadURL !== null)
			URL.revokeObjectURL(downloadURL);
	}

	var canvas = drawCanvas();
	if (canvas === null) {
		event.preventDefault();
		return;
	}

	if (downloadBlobURL && canvas.toBlob === undefined) // for Chrome and Safari
		downloadBlobURL = false;

	if (downloadBlobURL) {
		event.preventDefault();
		canvas.toBlob(function(blob) {
			downloadLink.href = downloadURL = URL.createObjectURL(blob);
			downloadLinkReady = true;
			downloadLink.click();
		}, downloadType, downloadQuality);
	} else {
		downloadLink.href = canvas.toDataURL(downloadType, downloadQuality);
	}
}
function overlayCanvas(event)
{
	event.preventDefault();

	var textNode = event.currentTarget.firstChild;

	if (textNode.nodeValue === "Hide Canvas") {
		document.getElementById("canvas").style.display = "none";
		controlDiv.style.display = "block";
		textNode.nodeValue = "Overlay Canvas";
		return;
	}

	var canvas = drawCanvas();
	if (canvas === null)
		return;

	canvas.style.left = photoDiv.offsetLeft + "px";
	canvas.style.top = photoDiv.offsetTop + "px";
	canvas.style.display = "block";
	controlDiv.style.display = "none";
	textNode.nodeValue = "Hide Canvas";
}
var standardUI = {
	create: function(filter, info)
	{
		var option = filter.option;
		var changeHandler = function(event) { changeFilterValue(filter, event); };
		var keydownHandler = function(event) { return handleSliderKeyDown(filter, event); };

		var sliderElement = document.createElement('INPUT');
		sliderElement.type = 'range';
		sliderElement.min = option.minValue;
		sliderElement.max = option.maxValue;
		sliderElement.value = option.defaultValue;
		sliderElement.addEventListener('change', changeHandler, false);
		sliderElement.addEventListener('keydown', keydownHandler, false);

		var inputElement = document.createElement('INPUT');
		inputElement.type = 'text';
		inputElement.size = 4;
		inputElement.maxLength = 4;
		inputElement.value = option.defaultValue;
		inputElement.addEventListener('change', changeHandler, false);

		var div = filter.uiDiv;
		div.appendChild(sliderElement);
		div.appendChild(inputElement);
		div.appendChild(document.createTextNode(option.unit));

		filter.value = option.defaultValue;
		filter.sliderElement = sliderElement;
		filter.inputElement = inputElement;

		if (info === undefined) return;

		var value = parseInt(info.value, 10);
		if (isNaN(value) || value != info.value || value === option.defaultValue
			|| value < option.minValue
			|| value > option.maxValue) return;

		sliderElement.value = value;
		inputElement.value = value;
		filter.value = value;
	},
	remove: function(filter)
	{
		var div = filter.uiDiv;
		while (div.firstChild)
			div.removeChild(div.firstChild);

		delete filter.sliderElement;
		delete filter.inputElement;
	},
	setDefault: function(filter)
	{
		var option = filter.option;
		filter.sliderElement.min = option.minValue;
		filter.sliderElement.max = option.maxValue;

		filter.value = option.defaultValue;
		filter.sliderElement.value = filter.value;
		filter.inputElement.value = filter.value;
		filter.inputElement.nextSibling.nodeValue = option.unit;
	},
	setValueForURL: function(filter, infoList)
	{
		if (filter.value !== filter.option.defaultValue)
			infoList.push(filter.value);
	}
};
var blurUI = {
	create: function(filter, info)
	{
		standardUI.create(filter, info);
		this._createFromStandard(filter, info);
	},
	remove: function(filter)
	{
		this._revertToStandard(filter);
		standardUI.remove(filter);
	},
	_createFromStandard: function(filter, info)
	{
		var edgeSelect = document.createElement('SELECT');
		edgeSelect.add(new Option('duplicate', 'duplicate', true, true));
		edgeSelect.add(new Option('wrap', 'wrap'));
		edgeSelect.add(new Option('black', 'none'));
		edgeSelect.add(new Option('mirror', 'mirror'));
		edgeSelect.addEventListener('change', function(event) {
			filter.edgeMode = edgeSelect.options[edgeSelect.selectedIndex];
			manageFilters(filter);
		}, false);

		var div = filter.uiDiv;
		div.appendChild(document.createElement('BR'));
		div.appendChild(document.createTextNode('Edge Mode:'));
		div.appendChild(edgeSelect);
		div.className = 'uiDiv uiDivBlur';
		div.parentNode.className = 'ui2';

		filter.edgeMode = edgeSelect.options[0];

		if (info === undefined) return;

		var edgeMode = parseInt(info.extraValue, 10);
		if (!isNaN(edgeMode) && edgeMode == info.extraValue && edgeMode > 0 && edgeMode <= 3) {
			edgeSelect.selectedIndex = edgeMode;
			filter.edgeMode = edgeSelect.options[edgeMode];
		}
	},
	createFromStandard: function(filter)
	{
		standardUI.setDefault(filter);
		this._createFromStandard(filter);
	},
	_revertToStandard: function(filter)
	{
		var div = filter.uiDiv;
		div.removeChild(div.lastChild);
		div.removeChild(div.lastChild);
		div.removeChild(div.lastChild);
		div.className = 'uiDiv';
		div.parentNode.className = 'ui1';

		delete filter.edgeMode;
	},
	revertToStandard: function(filter)
	{
		this._revertToStandard(filter);
		standardUI.setDefault(filter);
	},
	setDefault: function(filter)
	{
		standardUI.setDefault(filter);
	},
	setValueForURL: function(filter, infoList)
	{
		if (!filter.edgeMode.defaultSelected) {
			infoList.push(filter.value);
			infoList.push(filter.edgeMode.index);
		} else if (filter.value !== 0)
			infoList.push(filter.value);
	},
	getInfo: function(filter)
	{
		return filter.edgeMode.value;
	}
};
var polarUI = {
	create: function(filter, info)
	{
		var radiusSelect = document.createElement('SELECT');
		radiusSelect.add(new Option('diagonal/2', '0', true, true));
		radiusSelect.add(new Option('width/2', '1'));
		radiusSelect.add(new Option('height/2', '2'));
		radiusSelect.add(new Option('height', '3'));
		radiusSelect.addEventListener('change',
			function(event) {filter.value = radiusSelect.selectedIndex;}, false);

		var edgeSelect = document.createElement('SELECT');
		edgeSelect.add(new Option('duplicate', '0', true, true));
		edgeSelect.add(new Option('black', '1'));
		edgeSelect.add(new Option('transparent', '2'));
		edgeSelect.addEventListener('change',
			function(event) {filter.edgeMode = edgeSelect.selectedIndex;}, false);

		var div = filter.uiDiv;
		div.appendChild(document.createTextNode('Radius:'));
		div.appendChild(radiusSelect);
		div.appendChild(document.createElement('BR'));
		div.appendChild(document.createTextNode('Edge Mode:'));
		div.appendChild(edgeSelect);
		div.className = 'uiDiv uiDivPolar';
		div.parentNode.className = 'ui2';

		filter.value = 0;
		filter.edgeMode = 0;

		if (info !== undefined) {
			var value = parseInt(info.value, 10);
			if (!isNaN(value) && value == info.value && value > 0 && value <= 3) {
				radiusSelect.selectedIndex = value;
				filter.value = value;
			}
			var edgeMode = parseInt(info.extraValue, 10);
			if (!isNaN(edgeMode) && edgeMode == info.extraValue && edgeMode > 0 && edgeMode <= 2) {
				edgeSelect.selectedIndex = edgeMode;
				filter.edgeMode = edgeMode;
			}
		}
	},
	remove: function(filter)
	{
		var div = filter.uiDiv;
		while (div.firstChild)
			div.removeChild(div.firstChild);

		div.className = 'uiDiv';
		div.parentNode.className = 'ui1';

		delete filter.edgeMode;
	},
	createFromStandard: function(filter)
	{
		standardUI.remove(filter);
		this.create(filter);
	},
	revertToStandard: function(filter)
	{
		this.remove(filter);
		standardUI.create(filter);
	},
	setDefault: function(filter)
	{
	},
	setValueForURL: function(filter, infoList)
	{
		if (filter.edgeMode !== 0) {
			infoList.push(filter.value);
			infoList.push(filter.edgeMode);
		} else if (filter.value !== 0)
			infoList.push(filter.value);
	},
	getInfo: function(filter)
	{
		return filter.edgeMode;
	}
};
var convolveUI = {
	create: function(filter, info)
	{
		var opSelect = document.createElement('SELECT');
		opSelect.add(new Option('none', '0', true, true));
		opSelect.add(new Option('sharpen', '1'));
		opSelect.add(new Option('sobel x+y', '2'));
		opSelect.add(new Option('sobel x', '3'));
		opSelect.add(new Option('sobel y', '4'));
		opSelect.add(new Option('prewitt x+y', '5'));
		opSelect.add(new Option('prewitt x', '6'));
		opSelect.add(new Option('prewitt y', '7'));
		opSelect.add(new Option('edge detect 1', '8'));
		opSelect.add(new Option('edge detect 2', '9'));
		opSelect.add(new Option('emboss 1', '10'));
		opSelect.add(new Option('emboss 2', '11'));
		opSelect.addEventListener('change', function(event) {
			filter.value = opSelect.selectedIndex;
			manageFilters(filter);
		}, false);

		var div = filter.uiDiv;
		div.appendChild(opSelect);
		div.className = 'uiDiv uiDivConvolve';
		div.parentNode.className = 'ui2';

		filter.value = 0;

		if (info === undefined) return;

		var value = parseInt(info.value, 10);
		if (!isNaN(value) && value == info.value && value > 0 && value <= 11) {
			opSelect.selectedIndex = value;
			filter.value = value;
		}
	},
	remove: function(filter)
	{
		var div = filter.uiDiv;
		div.removeChild(div.firstChild);

		div.className = 'uiDiv';
		div.parentNode.className = 'ui1';
	},
	createFromStandard: function(filter)
	{
		standardUI.remove(filter);
		this.create(filter);
	},
	revertToStandard: function(filter)
	{
		this.remove(filter);
		standardUI.create(filter);
	},
	setDefault: function(filter)
	{
	},
	setValueForURL: function(filter, infoList)
	{
		if (filter.value !== 0)
			infoList.push(filter.value);
	}
};
function FilterOption(name, unit, defaultValue, minValue, maxValue, applyFilter, svgOnly, createSVGFilter)
{
	this.name = name;
	this.unit = unit;
	this.defaultValue = defaultValue;
	this.noChangeValue = defaultValue;
	this.ui = standardUI;
	this.minValue = minValue;
	this.maxValue = maxValue;
	this.applyFilter = applyFilter;
	this.svgOnly = svgOnly;
	this.createSVGFilter = createSVGFilter;
}
function simpleFilter(applyFilter)
{
	return function(context, imageData, amount, channels) {
		applyFilter(imageData.data, amount, channels);
		return imageData;
	}
}
var filterOptions = [
new FilterOption('brightness', '%',   100, 0, 2000, simpleFilter(applyBrightnessFilter), false, createSVGBrightness),
new FilterOption('contrast',   '%',   100, 0,  800, simpleFilter(applyContrastFilter),   false, createSVGContrast),
new FilterOption('saturate',   '%',   100, 0, 1000, simpleFilter(applySaturateFilter),   false, createSVGSaturate),
new FilterOption('grayscale',  '%',     0, 0,  100, simpleFilter(applyGrayscaleFilter),  false, createSVGGrayscale),
new FilterOption('sepia',      '%',     0, 0,  100, simpleFilter(applySepiaFilter),      false, createSVGSepia),
new FilterOption('hue-rotate', 'deg',   0, 0,  360, simpleFilter(applyHueRotateFilter),  false, createSVGHueRotate),
new FilterOption('threshold',  '',    128, 0,  256, simpleFilter(applyThreshold),        true,  createSVGThreshold),
new FilterOption('invert',     '%',     0, 0,  100, simpleFilter(applyInvertFilter),     false, createSVGInvert),
new FilterOption('convolve',   '',      0, 0,   11, applyConvolution,                    true,  createSVGConvolve),
new FilterOption('blur',       'px',    0, 0,   20, applyBlurFilter,                     false, createBlurFilter),
new FilterOption('blur-x',     'px',    0, 0,   40, applyBlurXFilter,                    true,  createBlurXFilter),
new FilterOption('blur-y',     'px',    0, 0,   40, applyBlurYFilter,                    true,  createBlurYFilter),
new FilterOption('d-blur-x',   'px',    0,-100,100, applyDBlurX,                         true,  svgCannotImplement),
new FilterOption('d-blur-y',   'px',    0,-100,100, applyDBlurY,                         true,  svgCannotImplement),
new FilterOption('polar',      '',      0, 0,    3, applyPolarTransform,                 true,  svgCannotImplement),
new FilterOption('depolar',    '',      0, 0,    3, applyReversePolarTransform,          true,  svgCannotImplement),
];
function Filter(tableCell, info)
{
	this.selectElement = tableCell.firstChild;
	this.tableRow = tableCell.parentNode;
	this.uiDiv = tableCell.lastChild;
	this.option = filterOptions[this.selectElement.selectedIndex];
	this.option.ui.create(this, info);
	this.channels = info.channels;
	this.manage = true;
	this.id = 0;
}
function swapXYFilters()
{
	for (var option of filterOptions)
	{
		var name = option.name;
		if (name.substr(-2) === '-x') {
			var swapName = name.substr(0, name.length - 1) + 'y';
			option.swapIndex = filterIndex[swapName];

			var swapOption = filterOptions[option.swapIndex];
			swapOption.swapIndex = filterIndex[option.name];

			var createSVGFilter = option.createSVGFilter;
			option.createSVGFilter = swapOption.createSVGFilter;
			swapOption.createSVGFilter = createSVGFilter;
		} else if (name.substr(-2) !== '-y') {
			option.swapIndex = null;
		}
	}
	for (var filter of filters)
		if (filter.option.swapIndex !== null)
		{
			filter.selectElement.selectedIndex = filter.option.swapIndex;
			filter.option = filterOptions[filter.option.swapIndex];
		}
}
function markupFilterStyle(inData)
{
	var outData = '';

	var k, i = 0;
	while (i < inData.length)
	{
		k = inData.indexOf('(', i);
		if (k < 0) { outData += inData.substr(i); break; }
		outData += '<span class="cA">' + inData.substr(i, k - i) + '</span>(';
		i = k + 1;
		k = inData.indexOf(')', i);
		if (k < 0) { outData += inData.substr(i); break; }
		outData += '<span class="cV">' + inData.substr(i, k - i) + '</span>)';
		i = k + 1;
	}

	return outData;
}
function markupTag(inData)
{
	var k = inData.indexOf(' ');
	var tag = k < 0 ? inData : inData.substr(0, k);
	var outData = '<span class="cT">' + tag + '</span>';

	var i = tag.length + 1;
	while (i < inData.length)
	{
		k = inData.indexOf('=', i);
		outData += ' <span class="cA">' + inData.substr(i, k - i) + '</span>';
		i = k + 2;
		k = inData.indexOf('"', i);
		outData += '=&quot;<span class="cV">' + inData.substr(i, k - i) + '</span>&quot;';
		i = k + 2;
	}

	return [tag, outData];
}
function getURL()
{
	var filterList = [];
	for (var filter of filters)
	{
		var option = filter.option;
		var channels = filter.channels;

		var rgb = '';
		if ((channels & 1) !== 0) rgb += 'r';
		if ((channels & 2) !== 0) rgb += 'g';
		if ((channels & 4) !== 0) rgb += 'b';

		var infoList = [option.name, rgb];

		option.ui.setValueForURL(filter, infoList);

		if (infoList.length === 2 && rgb === 'rgb')
			filterList.push(option.name);
		else
			filterList.push(infoList.join(','));
	}

	var url = window.location;

	url = url.protocol + '//' + url.host + url.pathname;
	url += '?f=' + filterList.join('/');
	if (imageFiles === undefined)
		url += '&i=' + document.getElementById('fileNameField').value;

	return url;
}
function showFilterCode(event)
{
	event.preventDefault();

	var filterStyle = markupFilterStyle(photo.style.webkitFilter || 'none');

	var css = '<span class="cT">-webkit-filter</span>: ' + filterStyle +
		';\n<span class="cT">filter</span>: ' + filterStyle + ';\n';

	var html = document.getElementById('svgRoot').innerHTML;
	var svg = '&lt;' + markupTag('svg width="0" height="0"')[1] + '&gt;';

	var j = 0;
	var indent = 0;
	var previousTag = null;

	while ((j = html.indexOf('<', j)) >= 0)
	{
		var endTag = html.charAt(j + 1) === '/';
		var k = endTag ? j + 2 : j + 1;

		j = html.indexOf('>', k);
		var [tag, tagData] = markupTag(html.substr(k, j - k));

		if (endTag) {
			--indent;
			if  (tag !== previousTag) {
				svg += '\n';
				for (k = 0; k < indent; ++k) svg += '  ';
			}
			svg += '&lt;/' + tagData + '&gt;';
			previousTag = null;
		} else {
			svg += '\n';
			for (k = 0; k < indent; ++k) svg += '  ';
			svg += '&lt;' + tagData + '&gt;';
			previousTag = tag;
			++indent;
		}
	}

	svg += '\n&lt;/' + markupTag('svg')[1] + '&gt;\n';

	var urlCode = document.getElementById("urlCode");
	var cssCode = document.getElementById("cssCode");
	var svgCode = document.getElementById("svgCode");

	urlCode.style.width = 'auto';
	urlCode.style.height = 'auto';
	cssCode.style.width = 'auto';
	cssCode.style.height = 'auto';
	svgCode.style.width = 'auto';
	svgCode.style.height = 'auto';

	urlCode.innerHTML = getURL();
	cssCode.innerHTML = css;
	svgCode.innerHTML = svg;

	var filterCodeDiv = document.getElementById("filterCodeDiv");
	filterCodeDiv.style.display = "block";

	if (urlCode.clientWidth > 880)
		// Add a blank line so the horizontal scroll bar doesn't cover the URL when scrolling.
		urlCode.innerHTML += '\n\n';

	var width = Math.min(880, Math.max(
		urlCode.clientWidth,
		cssCode.clientWidth,
		svgCode.clientWidth)) + 'px';

	urlCode.style.width = width;
	cssCode.style.width = width;
	svgCode.style.width = width;
	if (svgCode.clientHeight > 450) svgCode.style.height = '450px';

	centerElement(filterCodeDiv, null, null);
}
function hideFilterCode()
{
	document.getElementById("filterCodeDiv").style.display = "none";
}
function applyFilters()
{
	var filterList = [];
	for (var filter of filters)
	{
		var option = filter.option;
		if (filter.value === option.noChangeValue || filter.channels === 0)
			continue;
		if (filter.manage)
			manageFilter(filter, option);
		if (filter.id === 0)
			filterList.push(option.name + '(' + filter.value + option.unit + ')');
		else if (filter.id > 0)
			filterList.push('url(#filter' + filter.id + ')');
	}
	var filterStyle = filterList.length === 0 ? 'none' : filterList.join(' ');
	photo.style.webkitFilter = filterStyle;
	photo.style.filter = filterStyle;
}
function manageFilter(filter, option)
{
	if (filter.id !== 0)
	{
		removeSVGFilter(filter.id);
		filter.id = 0;
	}
	if (option.svgOnly || filter.channels < 7)
	{
		var amount = option.unit === '%' ? filter.value / 100 : filter.value;
		var info = option.ui.getInfo ? option.ui.getInfo(filter) : undefined;

		filter.id = option.createSVGFilter(amount, filter.channels, info);
	}
	filter.manage = false;
}
function manageFilters(filter)
{
	filter.manage = true;
	applyFilters();
}
function changeFilterName(event)
{
	var selectElement = event.currentTarget;
	var tableRow = selectElement.parentNode.parentNode;

	var filter = filters[parseInt(tableRow.id.substr(9), 10)];
	var option = filterOptions[selectElement.selectedIndex];

	var oldUI = filter.option.ui;
	var newUI = option.ui;

	filter.option = option;

	if (oldUI === newUI)
		newUI.setDefault(filter);
	else if (oldUI === standardUI)
		newUI.createFromStandard(filter);
	else if (newUI === standardUI)
		oldUI.revertToStandard(filter);
	else {
		oldUI.remove(filter);
		newUI.create(filter);
	}

	manageFilters(filter);
}
function changeFilterValue(filter, event)
{
	var inputElement = event.currentTarget;
	var option = filter.option;
	var value = parseInt(inputElement.value, 10);

	if (isNaN(value) || value != inputElement.value || value < option.minValue || value > option.maxValue) {
		inputElement.value = filter.value;
	} else if (value != filter.value) {
		filter.value = value;
		if (inputElement === filter.sliderElement)
			filter.inputElement.value = value;
		else
			filter.sliderElement.value = value;
		manageFilters(filter);
	}
}
function handleSliderKeyDown(filter, event)
{
	var key = event.key || event.keyIdentifier;
	if (key === 'Tab' || key === 'U+0009')
		return true;

	event.preventDefault();
	event.stopPropagation();

	var option = filter.option;
	var value = filter.value;
	var step = Math.min(10, Math.max(1, Math.floor((option.maxValue - option.minValue) / 20)));

	if (key === 'ArrowLeft' || key === 'Left') {
		if (value === option.minValue)
			return false;
		value -= step;
		if (value < option.minValue)
			value = option.minValue;
	} else if (key === 'ArrowRight' || key === 'Right') {
		if (value === option.maxValue)
			return false;
		value += step;
		if (value > option.maxValue)
			value = option.maxValue;
	} else
		return false;

	filter.value = value;
	filter.inputElement.value = value;
	filter.sliderElement.value = value;

	manageFilters(filter);
	return false;
}
function addFilterRowBefore(event)
{
	var span = event.currentTarget;
	var tableRow = span.parentNode.parentNode;
	var rowNumber = parseInt(tableRow.id.substr(9), 10); // e.g. filterRow0

	if (rowNumber === 0) // Remove +
	{
		var firstCell = tableRow.firstChild;
		firstCell.replaceChild(createEmptyText(), firstCell.firstChild);
	}
	if (filters.length === 1) // Add X
	{
		var lastCell = tableRow.lastChild;
		lastCell.replaceChild(createXMarkAfter(), lastCell.firstChild);
	}

	for (var i = filters.length - 1; i >= rowNumber; --i)
	{
		filters[i].tableRow.id = 'filterRow' + (i + 1);
		filters[i + 1] = filters[i];
	}

	var newRow = createFilterRow(rowNumber);
	tableRow.parentNode.insertBefore(newRow, tableRow);
}
function addFilterRowAfter(event)
{
	var span = event.currentTarget;
	var tableRow = span.parentNode.parentNode;
	var rowNumber = parseInt(tableRow.id.substr(9), 10); // e.g. filterRow0

	if (filters.length === 1) // Add X
	{
		var lastCell = tableRow.lastChild;
		lastCell.replaceChild(createXMarkAfter(), lastCell.firstChild);
	}

	for (var i = filters.length - 1; i > rowNumber; --i)
	{
		filters[i].tableRow.id = 'filterRow' + (i + 1);
		filters[i + 1] = filters[i];
	}

	var newRow = createFilterRow(rowNumber + 1);
	tableRow.parentNode.insertBefore(newRow, tableRow.nextSibling);
}
function removeFilterRow(event)
{
	var span = event.currentTarget;
	var tableRow = span.parentNode.parentNode;
	var rowNumber = parseInt(tableRow.id.substr(9), 10); // e.g. filterRow0

	tableRow.parentNode.removeChild(tableRow);

	var filterId = filters[rowNumber].id;
	if (filterId !== 0)
		removeSVGFilter(filterId);

	for (var i = rowNumber; i < filters.length - 1; ++i)
	{
		filters[i] = filters[i + 1];
		filters[i].tableRow.id = 'filterRow' + i;
	}

	filters.length -= 1;

	if (filters.length === 1) // Remove X
	{
		var lastCell = filters[0].tableRow.lastChild;
		lastCell.replaceChild(createEmptyText(), lastCell.firstChild);
	}
	if (rowNumber === 0) // Add +
	{
		var firstCell = filters[0].tableRow.firstChild;
		firstCell.replaceChild(createPlusBefore(), firstCell.firstChild);
	}

	applyFilters();
}
function selectChannel(event)
{
	var span = event.currentTarget;
	var tableRow = span.parentNode.parentNode;
	var channel = span.firstChild.nodeValue;

	var filter = filters[parseInt(tableRow.id.substr(9), 10)]; // e.g. filterRow0
	var flag = channel === 'R' ? 1 : channel === 'G' ? 2 : 4;

	if ((filter.channels & flag) === 0) {
		filter.channels += flag;
		span.className = 'channelOn channel' + channel;
	} else {
		filter.channels -= flag;
		span.className = 'channelOff';
	}

	manageFilters(filter);
}
function createChannelSelector(tableCell, channel, on)
{
	var span = document.createElement('SPAN');
	span.className = on ? 'channelOn channel' + channel : 'channelOff';
	span.appendChild(document.createTextNode(channel));
	span.addEventListener('click', selectChannel, false);
	tableCell.appendChild(span);
}
function createClickableText(text, clickHandler)
{
	var span = document.createElement('SPAN');
	span.appendChild(document.createTextNode(text));
	span.className = 'clickable';
	span.addEventListener('click', clickHandler, false);
	return span;
}
function createPlusBefore()
{
	return createClickableText('+', addFilterRowBefore);
}
function createPlusAfter()
{
	return createClickableText('+', addFilterRowAfter);
}
function createXMarkAfter()
{
	return createClickableText('\u00D7', removeFilterRow);
}
function createEmptyText()
{
	return document.createTextNode('\u00A0');
}
function addFilterCell(tableRow, cellChild)
{
	var tableCell = document.createElement('TD');
	tableCell.appendChild(cellChild);
	tableRow.appendChild(tableCell);
}
function createFilterRow(rowNumber, info)
{
	if (info === undefined)
		info = {name: 'contrast', channels: 7};

	var tableRow = document.createElement('TR');
	tableRow.id = 'filterRow' + rowNumber;

	if (rowNumber === 0)
		addFilterCell(tableRow, createPlusBefore());
	else
		addFilterCell(tableRow, createEmptyText());

	var selectElement = document.createElement('SELECT');
	for (var option of filterOptions)
	{
		var name = option.name;
		if (option.createSVGFilter === svgCannotImplement)
			name += ' *';
		selectElement.add(new Option(name, option.name));
	}

	selectElement.selectedIndex = filterIndex[info.name];
	selectElement.addEventListener('change', changeFilterName, false);

	var uiDiv = document.createElement('DIV');
	uiDiv.className = 'uiDiv';

	var tableCell = document.createElement('TD');
	tableCell.appendChild(selectElement);
	createChannelSelector(tableCell, 'R', (info.channels & 1) !== 0);
	createChannelSelector(tableCell, 'G', (info.channels & 2) !== 0);
	createChannelSelector(tableCell, 'B', (info.channels & 4) !== 0);
	tableCell.appendChild(uiDiv);
	tableCell.className = 'ui1';
	tableRow.appendChild(tableCell);

	filters[rowNumber] = new Filter(tableCell, info);

	addFilterCell(tableRow, createPlusAfter());
	if (filters.length === 1)
		addFilterCell(tableRow, createEmptyText());
	else
		addFilterCell(tableRow, createXMarkAfter());

	return tableRow;
}
function parseQueryString()
{
	queryString = {
		filters: null,
		overlayCanvas: false,
		selectedImage: 0,
	};

	var q = window.location.search;

	if (typeof q !== 'string' || q.charAt(0) !== '?') return;

	for (var s of q.substr(1).split('&'))
	{
		if (s === 'o') {
			queryString.overlayCanvas = true;
			continue;
		}

		var i = s.indexOf('=');
		if (i < 1 || i === s.length - 1) continue;
		var k = s.substr(0, i);
		var v = s.substr(i + 1);

		if (k === 'f') {
			queryString.filters = v;
			continue;
		}
		if (k === 'i') {
			if (imageNames !== undefined) {
				i = imageNames.indexOf(v);
				if (i >= 0) {
					queryString.selectedImage = i;
					continue;
				}
			}
			imagePath = '';
			imageNames = [v];
		}
	}
}
function createFiltersFromQueryString()
{
	if (queryString.filters === null) return;

	var filterList = [];
	for (var s of queryString.filters.split('/'))
	{
		var [name, rgb, value, extraValue] = s.split(',', 4);

		if (!filterIndex.hasOwnProperty(name)) continue;

		var channels;
		if (rgb === undefined)
			channels = 7;
		else {
			channels = 0;
			for (var c of rgb.toUpperCase())
				if (c === 'R') channels |= 1;
				else if (c === 'G') channels |= 2;
				else if (c === 'B') channels |= 4;
		}

		filterList.push({name: name, channels: channels, value: value, extraValue: extraValue});
	}

	if (filterList.length === 0) return;

	var tableRow = createFilterRow(0, filterList[0]);
	var table = document.createElement('TABLE');
	table.appendChild(tableRow);

	if (filterList.length > 1) {
		var lastCell = tableRow.lastChild;
		lastCell.replaceChild(createXMarkAfter(), lastCell.firstChild);

		for (var i = 1; i < filterList.length; ++i)
			table.appendChild(createFilterRow(i, filterList[i]));
	}

	applyFilters();
	return table;
}
function createFilterDiv()
{
	for (var i = 0; i < filterOptions.length; ++i)
		filterIndex[filterOptions[i].name] = i;

	var option = filterOptions[filterIndex['threshold']];
	option.noChangeValue = null;

	option = filterOptions[filterIndex['polar']];
	option.ui = polarUI;
	option.noChangeValue = null;

	option = filterOptions[filterIndex['depolar']];
	option.ui = polarUI;
	option.noChangeValue = null;

	option = filterOptions[filterIndex['convolve']];
	option.ui = convolveUI;

	for (option of ['blur', 'blur-x', 'blur-y', 'd-blur-x', 'd-blur-y'])
		filterOptions[filterIndex[option]].ui = blurUI;

	var table = createFiltersFromQueryString();
	if (!table) {
		var tableRow = createFilterRow(0);
		table = document.createElement('TABLE');
		table.appendChild(tableRow);
	}

	var overlayCanvasLink = document.getElementById('overlayCanvasLink');
	var link = document.createElement('A');
	link.href = '#';
	link.appendChild(document.createTextNode('Overlay Canvas'));
	link.addEventListener('click', function(event)
		{event.preventDefault(); overlayCanvasLink.click();}, false);

	var note = document.createElement('DIV');
	note.appendChild(document.createTextNode('Filters marked by an asterisk (*) are not implemented in SVG.'));
	note.appendChild(document.createElement('BR'));
	note.appendChild(document.createTextNode('Click '));
	note.appendChild(link);
	note.appendChild(document.createTextNode(' to see the effect of these filters.'));

	var filterDiv = document.getElementById('filterDiv');
	filterDiv.appendChild(table);
	filterDiv.appendChild(note);
}
function toggleShowFilters(event)
{
	event.preventDefault();

	var filterDiv = document.getElementById('filterDiv');
	var toggleFiltersLink = document.getElementById('toggleFiltersLink').firstChild;

	if (filterDiv.style.display === 'none') {
		filterDiv.style.display = 'block';
		toggleFiltersLink.nodeValue = 'Hide Filters';
	} else {
		filterDiv.style.display = 'none';
		toggleFiltersLink.nodeValue = 'Show Filters';
	}
}
function browseFiles(event)
{
	event.preventDefault();
	document.getElementById("fileBrowser").click();
}
function loadFiles()
{
	var files = document.getElementById("fileBrowser").files;

	var newImageNames = [];
	var newImageFiles = [];

	for (var i = 0; i < files.length; ++i)
		if (files[i].type.substr(0, 6) === 'image/')
		{
			newImageNames.push(files[i].name);
			newImageFiles.push(files[i]);
		}

	if (newImageNames.length === 0) return;

	imageNames = newImageNames;
	imageFiles = newImageFiles;

	var fileNameField = document.getElementById("fileNameField");
	fileNameField.options.length = 0;
	fileNameField.selectedIndex = -1;

	loadImage();
}
function copyToClipboard()
{
	if (!copySupported) return;

	copySupported = document.execCommand("copy");

	if (copySupported) return;

	for (var id of ["copyURL", "copyCSS", "copySVG", "copyCropGeometry"])
		document.getElementById(id).firstChild.nodeValue = "Select";
}
function copyNode(event, elementId)
{
	event.preventDefault();
	window.getSelection().selectAllChildren(document.getElementById(elementId));
	copyToClipboard();
}
function copyURL(event)
{
	copyNode(event, "urlCode");
}
function copyCSS(event)
{
	copyNode(event, "cssCode");
}
function copySVG(event)
{
	copyNode(event, "svgCode");
}
function copyCropGeometry(event)
{
	event.preventDefault();
	document.getElementById("cropGeometry").select();
	copyToClipboard();
}
function documentKeyDown(event)
{
	if (event.target instanceof HTMLInputElement ||
		event.target instanceof HTMLSelectElement) return true;

	var key = event.key || event.keyIdentifier;

	if (key === 'g' || key === 'U+0047') {
		showCropGeometry = !showCropGeometry;
		document.getElementById("cropGeometryDiv").style.display = showCropGeometry ? 'block' : 'none';
	} else if (key === 'o' || key === 'U+004F') {
		document.getElementById("overlayCanvasLink").click();
	} else
		return true;

	event.preventDefault();
	event.stopPropagation();
	return false;
}
function disableCropElements(disable)
{
	var elementIds = [
		"cropWidthField",
		"cropHeightField",
		"cropXField",
		"cropYField",
		"cropButton",
		"undoButton",
		"rotateLeftButton",
		"rotateRightButton",
		"rotate180Button",
		"inverseAspectRatioCheckbox",
		"fileNameField"
	];

	for (var id of elementIds)
		document.getElementById(id).disabled = disable;
}
function bodyLoaded()
{
	if (typeof imagePath !== "string")
		imagePath = "";
	if (!Array.isArray(imageNames) || imageNames.length === 0)
		imageNames = undefined;

	disableCropElements(true);
	photo = document.getElementById("photo");
	cropper = document.getElementById("cropper");

	var photoDiv = document.getElementById("photoDiv");
	cropper.style.left = (photoDiv.offsetLeft + 4) + 'px';
	cropper.style.top = (photoDiv.offsetTop + 4) + 'px';

	controlDiv = document.getElementById("controlDiv");
	controlDiv.onmousedown = startControlDivDrag;

	// Hack for Mozilla to clear any previously selected files
	document.getElementById("fileBrowser").value = "";
	document.getElementById("cropGeometry").value = "";

	if (showCropGeometry)
		document.getElementById("cropGeometryDiv").style.display = "block";

	downloadLink = document.getElementById("downloadLink");
	downloadLink.addEventListener("click", saveImage, false);

	parseQueryString();
	createFilterDiv();
	document.getElementById("toggleFiltersLink").addEventListener("click", toggleShowFilters, false);
	document.getElementById("showFilterCode").addEventListener("click", showFilterCode, false);
	document.getElementById("copyURL").addEventListener("click", copyURL, false);
	document.getElementById("copyCSS").addEventListener("click", copyCSS, false);
	document.getElementById("copySVG").addEventListener("click", copySVG, false);
	document.getElementById("fileBrowserLink").addEventListener("click", browseFiles, false);
	document.getElementById("copyCropGeometry").addEventListener("click", copyCropGeometry, false);
	document.getElementById("overlayCanvasLink").addEventListener("click", overlayCanvas, false);
	document.addEventListener("keydown", documentKeyDown, false);
	loadImage();
}
</script>
</head>
<body onload="bodyLoaded()">

<div id="photoDiv"><img id="photo" /></div>
<div id="cropper">
<div id="resizeNW"></div>
<div id="resizeNE"></div>
<div id="resizeSW"></div>
<div id="resizeSE"></div>
</div>
<a href="#" id="overlayCanvasLink">Overlay Canvas</a>

<div id="filterCodeDiv">
URL: <a href="#" id="copyURL">Copy</a><br><code id="urlCode"></code>
CSS: <a href="#" id="copyCSS">Copy</a><br><code id="cssCode"></code>
SVG: <a href="#" id="copySVG">Copy</a><br><code id="svgCode"></code>
<input type="button" value="Close" onclick="hideFilterCode()" />
</div>
<div id="controlDiv">
Crop Area (Width x Height + X + Y): <input
	type="text" id="cropWidthField" size="4" value="" onchange="changeCropWidth()" />x<input
	type="text" id="cropHeightField" size="4" value="" onchange="changeCropHeight()" />+<input
	type="text" id="cropXField" size="4" value="" onchange="changeCropX()" />+<input
	type="text" id="cropYField" size="4" value="" onchange="changeCropY()" />
<br>
<input type="button" value="Crop" id="cropButton" onclick="crop()" />
<input type="button" value="Undo" id="undoButton" onclick="undo()" />
<input type="button" value="Rotate Left" id="rotateLeftButton" onclick="rotatePhoto(270)" />
<input type="button" value="Rotate Right" id="rotateRightButton" onclick="rotatePhoto(90)" />
<input type="button" value="Rotate 180" id="rotate180Button" onclick="rotatePhoto(180)" />
<br>
Display Width x Height: <input
	type="text" readonly id="divWidth" size="4" value="" />x<input
	type="text" readonly id="divHeight" size="4" value="" />
<span id="aspectRatio">(:)</span>
<br>
<input type="checkbox" id="inverseAspectRatioCheckbox" onclick="toggleInverseAspectRatio()" />
Crop Inverse Aspect Ratio
&nbsp;&nbsp;<a href="#" id="toggleFiltersLink">Hide Filters</a>
(<a href="#" id="showFilterCode">Code</a>)
&nbsp;&nbsp;<a href="#" id="fileBrowserLink">Browse Files</a>
<br>
<input type="file" id="fileBrowser" accept="image/*" multiple onchange="loadFiles()" />
<select id="fileNameField" onchange="loadImage()"></select>
<input type="button" id="prevButton" value="Previous" onclick="prevImage()" />
<input type="button" id="nextButton" value="Next" onclick="nextImage()" />
<a download href="#" id="downloadLink">Save</a>
<br>
<div id="cropGeometryDiv"><input type="text" id="cropGeometry" size="44" value="" readonly />
<a href="#" id="copyCropGeometry">Copy</a></div>
<div id="filterDiv"></div>
</div>

<canvas id="canvas"></canvas>
<div id="progressDiv"><span id="progressText">Loading</span><div id="spinDisc"></div></div>
<div id="failedDiv">Failed to load<br><input type="button" value="Close" onclick="hideFailed()" /></div>
<svg id="svgRoot" width="0" height="0" xmlns="http://www.w3.org/2000/svg"><defs></defs></svg>
</body>
</html>
