<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>PIE</title>
<style>
body {
	background-color: rgb(240,255,255); /* Azure */
	font-family: verdana;
	font-size: 10pt;
}
input, select {
	font-family: verdana;
	font-size: 10pt;
	margin-top: 2px;
	margin-bottom: 2px;
}
#progressDiv, #failedDiv {
	background-color: rgb(230,230,250); /* Lavender */
	border: 2px solid black;
	border-radius: 10px;
	display: none;
	font-size: 14pt;
	text-align: center;
	padding: 10px;
	position: fixed;
}
#failedDiv {
	padding-bottom: 4px;
}
#progressText {
	position: relative;
	top: -10px;
	padding-right: 12px;
}
@keyframes spinDiscAnimation {
	from { transform: rotateZ(0deg); }
	to { transform: rotateZ(360deg); }
}
#spinDisc {
	display: inline-block;
	width: 0px;
	height: 0px;

	border-top: 20px solid rgb(65,105,225); /* RoyalBlue */
	border-left: 20px solid rgb(135,206,250); /* LightSkyBlue */
	border-bottom: 20px solid rgb(65,105,225); /* RoyalBlue */
	border-right: 20px solid rgb(135,206,250); /* LightSkyBlue */
	border-radius: 20px;

	animation-name: spinDiscAnimation;
	animation-duration: 1.5s;
	animation-iteration-count: infinite;
	animation-timing-function: linear;
	animation-play-state: paused;
}
#filterCodeDiv {
	background-color: rgb(230,230,250); /* Lavender */
	border: 2px solid black;
	border-radius: 10px;
	display: none;
	padding: 6px 10px 4px 10px; /* top right bottom left */
	position: absolute;
}
code {
	background-color: rgb(245,245,220); /* Beige */
	border-radius: 10px;
	display: block;
	overflow: scroll;
	padding: 4px;
	white-space: pre;
}
#cssCode, #urlCode {
	margin-bottom: 4px;
}
#copyCSS, #copySVG, #copyURL {
	background-color: rgb(245,222,179); /* Wheat */
	border-radius: 6px;
	float: right;
	font-size: 8pt;
	padding: 1px 4px 1px 4px;
	text-transform: uppercase;
}
.cT { color: rgb(0,100,0); } /* DarkGreen */
.cA { color: rgb(128,0,128); } /* Purple */
.cV { color: rgb(0,0,128); } /* Navy */
.action {
	background-color: rgb(245,222,179); /* Wheat */
	border-radius: 6px;
	color: rgb(0,0,205); /* MediumBlue */
	padding: 0px 4px 0px 4px;
}
#aboutLink, #overlayCanvasLink {
	background-color: rgb(245,222,179); /* Wheat */
	border-radius: 6px;
	display: inline-block;
	padding: 4px;
}
#aboutDiv {
	background-color: rgb(230,230,250); /* Lavender */
	border: 2px solid black;
	border-radius: 10px;
	box-shadow: inset 0 0 10px 0 rgba(0,0,0,.5);
	display: none;
	padding: 6px 10px 4px 10px; /* top right bottom left */
	position: absolute;
	width: 600px;
}
#controlDiv {
	background-color: rgba(230,230,250,0.8);
	border: 2px solid black;
	border-radius: 10px;
	text-align: center;
	width: 520px;
	padding: 2px;
	position: absolute;
	left: 52px;
	top: 422px;
}
#fileNameField {
	max-width: 290px;
}
#photoDiv {
	position: relative;
	overflow: hidden;
	width: 600px;
	height: 400px;
	border: 4px solid black;
}
#cropper {
	position: absolute;
	width: 596px; /* 600 with the border */
	height: 396px; /* 400 with the border */
	top: 12px;
	left: 12px;
	border: 2px dashed black;
	box-shadow: 0px 0px 4px 3px rgba(255,255,255,.5); /* offset-x offset-y blur-radius spread-radius color */
	cursor: move;
}
#resizeNW {
	position: absolute;
	width: 20px;
	height: 20px;
	top: -10px;
	left: -10px;
	cursor: nw-resize;
}
#resizeNE {
	position: absolute;
	width: 20px;
	height: 20px;
	top: -10px;
	right: -10px;
	cursor: ne-resize;
}
#resizeSW {
	position: absolute;
	width: 20px;
	height: 20px;
	bottom: -10px;
	left: -10px;
	cursor: sw-resize;
}
#resizeSE {
	position: absolute;
	width: 20px;
	height: 20px;
	bottom: -10px;
	right: -10px;
	cursor: se-resize;
}
a {
	text-decoration: none;
}
a:hover {
	color: rgb(218,69,0);
}
#convolveInfoDiv {
	background-color: rgb(230,230,250); /* Lavender */
	border: 2px solid black;
	border-radius: 10px;
	box-shadow: inset 0 0 10px 0 rgba(0,0,0,.5);
	display: none;
	padding: 6px 10px 4px 10px; /* top right bottom left */
	position: absolute;
	text-align: center;
}
#kernelTable td {
	text-align: center;
}
.kernel {
	border-spacing: 0;
	margin-left: auto;
	margin-right: auto;
}
.kernel td {
	font-family: monaco;
	padding: 0;
	white-space: pre;
}
.kernel td:first-child {border-left: 1px solid black;}
.kernel td:last-child {border-right: 1px solid black;}
.kernel tr:first-child > td:first-child {border-top: 1px solid black;}
.kernel tr:first-child > td:last-child {border-top: 1px solid black;}
.kernel tr:last-child > td:first-child {border-bottom: 1px solid black;}
.kernel tr:last-child > td:last-child {border-bottom: 1px solid black;}
#filterDiv table {
	margin-left: auto;
	margin-right: auto;
	border-collapse: collapse;
}
#filterDiv td {
	padding-left: 4px;
	padding-right: 4px;
	text-align: left;
}
#filterDiv select:first-child {
	vertical-align: middle;
}
.uiDiv {
	display: inline-block;
}
.uiDiv select {
	margin-top: 0px;
}
.uiDivBlur {
	vertical-align: top;
}
.uiDivBlur input[type="text"] {
	margin-top: 0px;
	margin-bottom: 0px;
}
.uiDivPolar {
	padding: 3px 0px 0px 4px; /* top right bottom left */
	vertical-align: top;
}
.uiDivConvolve select {
	margin-top: 2px;
	margin-left: 2px;
	margin-right: 2px;
}
.convAbs {
	border-width: 1px;
	cursor: pointer;
	margin-left: 4px;
	padding: 2px;
	vertical-align: middle;
}
.convAbsOn {
	background-color: rgb(255,255,255);
	border-style: inset;
}
.convAbsOff {
	background-color: rgb(230,230,230);
	border-style: outset;
	color: rgb(160,160,160);
}
.ui1 {
}
.ui2 {
	background-color: rgba(240,240,250,0.9);
	border-color: rgb(200,200,220);
	border-width: 1px;
	border-style: solid;
}
.clickable {
	font-size: 12pt;
	padding-left: 2px;
	padding-right: 2px;
	text-align: center;
}
.clickable:hover {
	background-color: rgb(136,136,136);
	color: rgb(255,255,255);
	cursor: pointer;
}
#fileBrowser {
	display: none;
}
input[type="range"] {
	margin: 0px 2px 0px 2px; /* top right bottom left */
	vertical-align: middle;
	width: 180px;
}
#canvas {
	border: 4px solid black;
	display: none;
	position: absolute;
}
#downloadLink {
	display: none;
}
.channelOn {
	border-style: inset;
	border-width: 1px;
	cursor: pointer;
	padding: 2px;
	vertical-align: middle;
}
.channelOff {
	background-color: rgb(230,230,230);
	border-style: outset;
	border-width: 1px;
	color: rgb(160,160,160);
	cursor: pointer;
	padding: 2px;
	vertical-align: middle;
}
.channelR {
	background-color: rgb(255,0,0); /* Red */
	color: rgb(255,192,203); /* Pink */
}
.channelR:hover {
	background-color: rgb(255,192,203); /* Pink */
	color: rgb(255,0,0); /* Red */
}
.channelG {
	background-color: rgb(0,128,0); /* Green */
	color: rgb(124,252,0); /* LawnGreen */
}
.channelG:hover {
	background-color: rgb(124,252,0); /* LawnGreen */
	color: rgb(0,128,0); /* Green */
}
.channelB {
	background-color: rgb(0,0,255); /* Blue */
	color: rgb(0,191,255); /* DeepSkyBlue */
}
.channelB:hover {
	background-color: rgb(0,191,255); /* DeepSkyBlue */
	color: rgb(0,0,255); /* Blue */
}
#cropGeometryDiv {
	display: none;
}
</style>
<script src="cropList.js"></script>
<script src="filter.js"></script>
<script>
var originalWidth;
var originalHeight;
var aspectX;
var aspectY;
var startX;
var startY;
var multiplyX;
var multiplyY;
var rotateAngle = 0;
var photoLeft;
var photoTop;
var cropInverseAspectRatio;
var cropped = false;
var minWidth;
var maxWidth;
var minHeight;
var maxHeight;

var photo;
var cropper;
var photoMinX;
var photoMinY;
var photoMaxX;
var photoMaxY;
var divWidth;
var divHeight;
var cropXField;
var cropYField;
var cropWidthField;
var cropHeightField;
var cropWidth;
var cropHeight;
var photoScale;
var cropperLeft;
var cropperTop;
var cropperWidth;
var cropperHeight;
var controlDiv;

var imagePath;
var imageNames;
var imageFiles;
var filters = [];
var filterIndex = {};
var hiddenCanvas;
var queryString;
var copySupported = true;
var showCropGeometry;
var oldDivWidth;
var oldDivHeight;

var svgImage, svgMode = false;
var ModeFlags = {SingleFilter: 1, SVGImage: 2, Video: 4};
var videoExtensions = ['m4v', 'mov', 'mp4', 'mpeg', 'mpg', 'ogg', 'ogv', 'webm'];

var downloadBlobURL = true;      // if true, create a blob: URL / if false, create a data: URL
var downloadLink;                // the HTML <a> element for the Save link
var downloadLinkReady = false;   // only used if downloadBlobURL is true
var downloadURL = null;          // only used if downloadBlobURL is true
var downloadQuality = 0.92;
var downloadType = "image/jpeg";

function releaseElement()
{
	document.onmousemove = null;
	document.onmouseup = null;
}
function photoDrag(event)
{
	var x, y;
	if (!svgMode || rotateAngle === 0) {
		x = startX + event.clientX;
		y = startY + event.clientY;
	} else if (rotateAngle === 90) {
		x = startY + event.clientY;
		y = startX - event.clientX;
	} else if (rotateAngle === 180) {
		x = startX - event.clientX;
		y = startY - event.clientY;
	} else {
		x = startY - event.clientY;
		y = startX + event.clientX;
	}

	var scaleX = divWidth / cropWidth;
	var scaleY = divHeight / cropHeight;

	var dW = Math.round((originalWidth - cropWidth) * scaleX);
	var dH = Math.round((originalHeight - cropHeight) * scaleY);

	var photoMinLeft, photoMinTop;
	var photoMaxLeft, photoMaxTop;

	if (rotateAngle === 0 || svgMode) {
		photoMinLeft = -dW;
		photoMaxLeft = 0;
		photoMinTop = -dH;
		photoMaxTop = 0;
	} else if (rotateAngle === 90) {
		photoMinLeft = 0;
		photoMaxLeft = dH;
		photoMinTop = -dW;
		photoMaxTop = 0;
	} else if (rotateAngle === 180) {
		photoMinLeft = 0;
		photoMaxLeft = dW;
		photoMinTop = 0;
		photoMaxTop = dH;
	} else {
		photoMinLeft = -dH;
		photoMaxLeft = 0;
		photoMinTop = 0;
		photoMaxTop = dW;
	}

	if (x > photoMaxLeft) x = photoMaxLeft;
	else if (x < photoMinLeft) x = photoMinLeft;
	if (y > photoMaxTop) y = photoMaxTop;
	else if (y < photoMinTop) y = photoMinTop;

	if (svgMode) {
		svgImage.setAttribute('x', x);
		svgImage.setAttribute('y', y);
	} else {
		photo.style.left = x + 'px';
		photo.style.top = y + 'px';
	}

	var x2 = Math.round(x / scaleX);
	var y2 = Math.round(y / scaleY);
	if (rotateAngle === 0 || svgMode) {
		photoLeft = x;
		photoTop = y;
		cropXField.value = -x2;
		cropYField.value = -y2;
	} else if (rotateAngle === 90) {
		photoLeft = y;
		photoTop = -x;
		cropXField.value = -y2;
		cropYField.value = x2;
	} else if (rotateAngle === 180) {
		photoLeft = -x;
		photoTop = -y;
		cropXField.value = x2;
		cropYField.value = y2;
	} else {
		photoLeft = -y;
		photoTop = x;
		cropXField.value = y2;
		cropYField.value = -x2;
	}

	if (!svgMode) updateUserSpaceFilters();
	return false;
}
function startPhotoDrag(event)
{
	if (svgMode) {
		var x = svgImage.x.baseVal.value;
		var y = svgImage.y.baseVal.value;
		if (rotateAngle === 0) {
			startX = x - event.clientX;
			startY = y - event.clientY;
		} else if (rotateAngle === 90) {
			startX = y + event.clientX;
			startY = x - event.clientY;
		} else if (rotateAngle === 180) {
			startX = x + event.clientX;
			startY = y + event.clientY;
		} else {
			startX = y - event.clientX;
			startY = x + event.clientY;
		}
	} else {
		startX = +photo.style.left.slice(0,-2) - event.clientX;
		startY = +photo.style.top.slice(0,-2) - event.clientY;
	}
	document.onmousemove = photoDrag;
	document.onmouseup = releaseElement;
	blurActiveElement();
	return false;
}
function cropperDrag(event)
{
	var x = startX + event.clientX;
	var y = startY + event.clientY;
	if (x < photoMinX) x = photoMinX;
	if (y < photoMinY) y = photoMinY;
	var x2 = Math.round((x - photoMinX) * photoScale);
	var y2 = Math.round((y - photoMinY) * photoScale);
	var dW = originalWidth - cropWidth;
	var dH = originalHeight - cropHeight;
	if (rotateAngle === 0) {
		if (x2 > dW) x2 = dW;
		if (y2 > dH) y2 = dH;
		cropXField.value = x2;
		cropYField.value = y2;
	} else if (rotateAngle === 90) {
		if (x2 > dH) x2 = dH;
		if (y2 > dW) y2 = dW;
		cropXField.value = y2;
		cropYField.value = dH - x2;
	} else if (rotateAngle === 180) {
		if (x2 > dW) x2 = dW;
		if (y2 > dH) y2 = dH;
		cropXField.value = dW - x2;
		cropYField.value = dH - y2;
	} else {
		if (x2 > dH) x2 = dH;
		if (y2 > dW) y2 = dW;
		cropXField.value = dW - y2;
		cropYField.value = x2;
	}
	if (x + cropperWidth > photoMaxX) x = photoMaxX - cropperWidth;
	if (y + cropperHeight > photoMaxY) y = photoMaxY - cropperHeight;
	cropper.style.left = (cropperLeft = x) + 'px';
	cropper.style.top = (cropperTop = y) + 'px';
	return false;
}
function startCropperDrag(event)
{
	startX = cropperLeft - event.clientX;
	startY = cropperTop - event.clientY;
	document.onmousemove = cropperDrag;
	document.onmouseup = releaseElement;
	blurActiveElement();
	return false;
}
function dragResize(event)
{
	var dX = (event.clientX - startX) * multiplyX;
	var dY = (event.clientY - startY) * multiplyY;
	var absdX = Math.abs(dX);
	var absdY = Math.abs(dY);
	if (absdX < 2 && absdY < 2)
		return false;
	if (dX * dY <= 0)
	{
		startX = event.clientX;
		startY = event.clientY;
		return false;
	}

	var delta;
	var aspect;
	var cropDimension;
	var setCropDimension;

	if (absdX > absdY) {
		delta = dX;
		setCropDimension = (rotateAngle === 0 || rotateAngle === 180) ? setCropWidth : setCropHeight;
	} else {
		delta = dY;
		setCropDimension = (rotateAngle === 0 || rotateAngle === 180) ? setCropHeight : setCropWidth;
	}

	if (setCropDimension === setCropWidth) {
		aspect = aspectX;
		cropDimension = cropWidth;
	} else {
		aspect = aspectY;
		cropDimension = cropHeight;
	}

	delta = Math.trunc(2 * delta * photoScale / aspect) * aspect;
	if (delta === 0)
		return false;

	setCropDimension(cropDimension - delta);
	startX = event.clientX;
	startY = event.clientY;
	return false;
}
function startDragResize(event)
{
	event.stopPropagation();
	startX = event.clientX;
	startY = event.clientY;
	document.onmousemove = dragResize;
	document.onmouseup = releaseElement;
	blurActiveElement();
	return false;
}
function startDragResizeNW(event)
{
	multiplyX = 1;
	multiplyY = 1;
	return startDragResize(event);
}
function startDragResizeNE(event)
{
	multiplyX = -1;
	multiplyY = 1;
	return startDragResize(event);
}
function startDragResizeSE(event)
{
	multiplyX = -1;
	multiplyY = -1;
	return startDragResize(event);
}
function startDragResizeSW(event)
{
	multiplyX = 1;
	multiplyY = -1;
	return startDragResize(event);
}
function greatestCommonDivisor(a, b)
{
	while (b !== 0)
	{
		var remainder = a % b;
		a = b;
		b = remainder;
	}
	return a;
}
function setDisplayArea()
{
	var width = 900;
	var height = 600;

	if (originalWidth > originalHeight && width > height ||
		originalWidth < originalHeight && width < height)
	{
		divWidth = width;
		divHeight = height;
	} else {
		divWidth = height;
		divHeight = width;
	}

	if (divWidth > originalWidth)
		divWidth = originalWidth;
	if (divHeight > originalHeight)
		divHeight = originalHeight;

	if (divWidth / divHeight != originalWidth / originalHeight)
	{
		var m = Math.floor(divWidth / aspectX);
		if (m === 0)
			m = 1;
		divWidth = m * aspectX;
		divHeight = m * aspectY;
	}

	document.getElementById("divWidth").value = divWidth;
	document.getElementById("divHeight").value = divHeight;
	document.getElementById("aspectRatio").firstChild.nodeValue = '(' + aspectX + ':' + aspectY + ')';

	photoLeft = 0;
	photoTop = 0;

	var photoDiv = document.getElementById("photoDiv");
	photoDiv.style.width = divWidth + 'px';
	photoDiv.style.height = divHeight + 'px';
	photoMinX = photoDiv.offsetLeft + 4;
	photoMinY = photoDiv.offsetTop + 4;
	photoMaxX = photoDiv.offsetLeft + photoDiv.offsetWidth - 4;
	photoMaxY = photoDiv.offsetTop + photoDiv.offsetHeight - 4;

	if (svgMode) {
		svgImage.setAttribute('x', 0);
		svgImage.setAttribute('y', 0);
		svgImage.setAttribute('width', divWidth);
		svgImage.setAttribute('height', divHeight);
		var svgRoot = svgImage.parentNode;
		svgRoot.setAttribute('width', divWidth);
		svgRoot.setAttribute('height', divHeight);
		svgRoot.setAttribute('viewBox', [0, 0, divWidth, divHeight].join(' '));
		svgRoot.style.transform = 'none';
		svgRoot.style.cursor = 'default';
		svgRoot.onmousedown = preventDefault;
	} else {
		photo.style.left = '0px';
		photo.style.top = '0px';
		photo.style.width = divWidth + 'px';
		photo.style.height = divHeight + 'px';
		photo.style.transform = 'none';
		photo.style.cursor = 'default';
		photo.onmousedown = preventDefault;
	}

	if (rotateAngle === 90)
		swapXYFilters(270);
	else if (rotateAngle === 270)
		swapXYFilters(90);
	else if (rotateAngle === 180)
		reverseLRFilters();

	photoScale = originalWidth / divWidth;
	rotateAngle = 0;
	minWidth = divWidth;
	maxWidth = originalWidth;
	minHeight = divHeight;
	maxHeight = originalHeight;
}
function init()
{
	var gcd = greatestCommonDivisor(originalWidth, originalHeight);
	aspectX = originalWidth / gcd;
	aspectY = originalHeight / gcd;
	cropInverseAspectRatio = false;

	setDisplayArea();
	setInverseAspectRatioAbility();

	cropWidthField = document.getElementById("cropWidthField");
	cropHeightField = document.getElementById("cropHeightField");
	cropWidthField.value = cropWidth = Math.max(divWidth, originalWidth / 2);
	cropHeightField.value = cropHeight = Math.max(divHeight, originalHeight / 2);

	cropXField = document.getElementById("cropXField");
	cropYField = document.getElementById("cropYField");
	cropXField.value = (originalWidth - cropWidth) / 2;
	cropYField.value = (originalHeight - cropHeight) / 2;

	setCropperXY();
	cropperWidth = cropWidth / photoScale;
	cropperHeight = cropHeight / photoScale;
	cropper.style.width = (cropperWidth - 4) + 'px';
	cropper.style.height = (cropperHeight - 4) + 'px';
	cropper.onmousedown = startCropperDrag;

	document.getElementById("resizeNW").onmousedown = startDragResizeNW;
	document.getElementById("resizeNE").onmousedown = startDragResizeNE;
	document.getElementById("resizeSW").onmousedown = startDragResizeSW;
	document.getElementById("resizeSE").onmousedown = startDragResizeSE;

	if (document.getElementById("inverseAspectRatioCheckbox").checked)
		toggleInverseAspectRatio();
}
function setCropWidthAndHeight(width, height)
{
	var x = +cropXField.value + Math.floor(cropWidth / 2 - width / 2);
	var y = +cropYField.value + Math.floor(cropHeight / 2 - height / 2);

	if (x + width > originalWidth)
		x = originalWidth - width;
	else if (x < 0)
		x = 0;
	if (y + height > originalHeight)
		y = originalHeight - height;
	else if (y < 0)
		y = 0;

	cropXField.value = x;
	cropYField.value = y;
	cropWidthField.value = width;
	cropHeightField.value = height;
	cropWidth = width;
	cropHeight = height;

	width = Math.round(width / photoScale);
	height = Math.round(height / photoScale);
	if (rotateAngle === 0 || rotateAngle === 180) {
		cropperWidth = width;
		cropperHeight = height;
	} else {
		cropperWidth = height;
		cropperHeight = width;
	}
	cropper.style.width = (cropperWidth - 4) + 'px';
	cropper.style.height = (cropperHeight - 4) + 'px';
	setCropperXY();
}
function setCropWidth(width)
{
	if (width > maxWidth)
		width = maxWidth;
	else if (width < minWidth || isNaN(width))
		width = minWidth;

	width -= width % aspectX;
	setCropWidthAndHeight(width, width / aspectX * aspectY);
}
function setCropHeight(height)
{
	if (height > maxHeight)
		height = maxHeight;
	else if (height < minHeight || isNaN(height))
		height = minHeight;

	height -= height % aspectY;
	setCropWidthAndHeight(height / aspectY * aspectX, height);
}
function changeCropWidth()
{
	setCropWidth(+cropWidthField.value);
	if (cropped) crop();
}
function changeCropHeight()
{
	setCropHeight(+cropHeightField.value);
	if (cropped) crop();
}
function setPhotoX(x)
{
	if (svgMode)
		svgImage.setAttribute('x', x);
	else
		photo.style.left = x + 'px';
}
function setPhotoY(y)
{
	if (svgMode)
		svgImage.setAttribute('y', y);
	else
		photo.style.top = y + 'px';
}
function changeCropX()
{
	var x = +cropXField.value;

	if (x + cropWidth > originalWidth)
		x = originalWidth - cropWidth;
	else if (x < 0 || isNaN(x))
		x = 0;

	cropXField.value = x;
	setCropperXY();
	if (cropped) {
		photoLeft = Math.round(-x * divWidth / cropWidth);
		if (rotateAngle === 0 || svgMode) setPhotoX(photoLeft);
		else if (rotateAngle === 90) setPhotoY(photoLeft);
		else if (rotateAngle === 180) setPhotoX(-photoLeft);
		else setPhotoY(-photoLeft);
		setSpecParam();
	}
}
function changeCropY()
{
	var y = +cropYField.value;

	if (y + cropHeight > originalHeight)
		y = originalHeight - cropHeight;
	else if (y < 0 || isNaN(y))
		y = 0;

	cropYField.value = y;
	setCropperXY();
	if (cropped) {
		photoTop = Math.round(-y * divHeight / cropHeight);
		if (rotateAngle === 0 || svgMode) setPhotoY(photoTop);
		else if (rotateAngle === 90) setPhotoX(-photoTop);
		else if (rotateAngle === 180) setPhotoY(-photoTop);
		else setPhotoX(photoTop);
		setSpecParam();
	}
}
function setSpecParam()
{
	document.getElementById("cropGeometry").value = "('"
		+ document.getElementById("fileNameField").value + "', '"
		+ cropWidth + "x" + cropHeight + "+"
		+ cropXField.value + "+" + cropYField.value + "')";
	manageUserSpaceFilters();
}
function crop()
{
	if (cropInverseAspectRatio && !cropped)
		turnPhotoDiv(true);

	var scaleX = divWidth / cropWidth;
	var scaleY = divHeight / cropHeight;

	var width = Math.round(originalWidth * scaleX);
	var height = Math.round(originalHeight * scaleY);

	photoLeft = Math.round(-cropXField.value * scaleX);
	photoTop = Math.round(-cropYField.value * scaleY);

	if (svgMode) {
		svgImage.setAttribute('width', width);
		svgImage.setAttribute('height', height);
	} else {
		photo.style.width = width + 'px';
		photo.style.height = height + 'px';
	}

	transformPhoto();
	setSpecParam();

	cropped = true;
	cropper.style.display = 'none';

	if (svgMode) {
		svgImage.parentNode.onmousedown = startPhotoDrag;
		svgImage.parentNode.style.cursor = 'move';
	} else {
		photo.onmousedown = startPhotoDrag;
		photo.style.cursor = 'move';
	}
}
function undo()
{
	if (cropInverseAspectRatio && cropped)
		turnPhotoDiv(true);

	photoLeft = 0;
	photoTop = 0;

	if (svgMode) {
		svgImage.setAttribute('width', divWidth);
		svgImage.setAttribute('height', divHeight);
	} else {
		photo.style.width = divWidth + 'px';
		photo.style.height = divHeight + 'px';
	}

	transformPhoto();
	setCropperXY();
	manageUserSpaceFilters();

	if (svgMode) {
		svgImage.parentNode.onmousedown = preventDefault;
		svgImage.parentNode.style.cursor = 'default';
	} else {
		photo.onmousedown = preventDefault;
		photo.style.cursor = 'default';
	}
	cropper.style.display = 'block';
	cropped = false;
}
function transformPhoto()
{
	var transform = "none";
	var photoWidth;
	var photoHeight;
	if (svgMode) {
		photoWidth = divWidth;
		photoHeight = divHeight;
	} else {
		photoWidth = photo.offsetWidth;
		photoHeight = photo.offsetHeight;
	}
	var delta = (photoWidth - photoHeight) / 2;
	var dX, dY, left, top;

	if (rotateAngle === 0) {
		dX = 0;
		dY = 0;
		left = photoLeft;
		top = photoTop;
	} else {
		if (rotateAngle === 90) {
			dX = delta;
			dY = delta + photoHeight - divHeight;
			left = -photoTop;
			top = photoLeft;
		} else if (rotateAngle === 180) {
			dX = photoWidth - divWidth;
			dY = photoHeight - divHeight;
			left = -photoLeft;
			top = -photoTop;
		} else {
			dX = -delta + photoWidth - divWidth;
			dY = -delta;
			left = photoTop;
			top = -photoLeft;
		}
		transform = "rotate(" + rotateAngle + "deg)";
		transform += " translate(" + dX + "px," + dY + "px)";
	}
	if (svgMode) {
		svgImage.parentNode.style.transform = transform;
		svgImage.setAttribute('x', photoLeft);
		svgImage.setAttribute('y', photoTop);
	} else {
		photo.style.transform = transform;
		photo.style.left = left + 'px';
		photo.style.top = top + 'px';
	}
}
function setCropperXY()
{
	var x = Math.round(cropXField.value / photoScale);
	var y = Math.round(cropYField.value / photoScale);
	if (rotateAngle === 0) {
		cropperLeft = photoMinX + x;
		cropperTop = photoMinY + y;
	} else if (rotateAngle === 90) {
		cropperLeft = photoMaxX - y - cropperWidth;
		cropperTop = photoMinY + x;
	} else if (rotateAngle === 180) {
		cropperLeft = photoMaxX - x - cropperWidth;
		cropperTop = photoMaxY - y - cropperHeight;
	} else {
		cropperLeft = photoMinX + y;
		cropperTop = photoMaxY - x - cropperHeight;
	}
	cropper.style.left = cropperLeft + 'px';
	cropper.style.top = cropperTop + 'px';
}
function turnPhotoDiv(swap)
{
	var photoDiv = document.getElementById("photoDiv");
	var width = photoDiv.offsetWidth - 8;
	var height = photoDiv.offsetHeight - 8;
	photoDiv.style.width = height + 'px';
	photoDiv.style.height = width + 'px';
	photoMinX = photoDiv.offsetLeft + 4;
	photoMinY = photoDiv.offsetTop + 4;
	photoMaxX = photoDiv.offsetLeft + photoDiv.offsetWidth - 4;
	photoMaxY = photoDiv.offsetTop + photoDiv.offsetHeight - 4;
	if (swap) {
		width = divWidth;
		height = divHeight;
		divWidth = height;
		divHeight = width;
		if (svgMode) {
			var svgRoot = svgImage.parentNode;
			svgRoot.setAttribute('width', divWidth);
			svgRoot.setAttribute('height', divHeight);
			svgRoot.setAttribute('viewBox', [0, 0, divWidth, divHeight].join(' '));
		}
	}
}
function rotatePhoto(angle)
{
	rotateAngle = (rotateAngle + angle) % 360;
	transformPhoto();
	var oldCropperLeft = cropperLeft - photoMinX;
	var oldCropperTop = cropperTop - photoMinY;
	if (angle === 90 || angle === 270) {
		turnPhotoDiv(false);
		swapXYFilters(angle);
		var width = cropperWidth;
		var height = cropperHeight;
		cropperWidth = height;
		cropperHeight = width;
		cropper.style.width = (cropperWidth - 4) + 'px';
		cropper.style.height = (cropperHeight - 4) + 'px';
	} else
		reverseLRFilters();
	if (angle === 90) {
		cropperLeft = photoMaxX - oldCropperTop - cropperWidth;
		cropperTop = photoMinY + oldCropperLeft;
	} else if (angle === 180) {
		cropperLeft = photoMaxX - oldCropperLeft - cropperWidth;
		cropperTop = photoMaxY - oldCropperTop - cropperHeight;
	} else if (angle === 270) {
		cropperLeft = photoMinX + oldCropperTop;
		cropperTop = photoMaxY - oldCropperLeft - cropperHeight;
	}
	cropper.style.left = cropperLeft + 'px';
	cropper.style.top = cropperTop + 'px';
}
function setInverseAspectRatioAbility()
{
	var checkbox = document.getElementById("inverseAspectRatioCheckbox");

	if (originalWidth > originalHeight)
		checkbox.disabled = (divWidth > originalHeight);
	else
		checkbox.disabled = (divHeight > originalWidth);

	if (checkbox.disabled)
		checkbox.checked = false;
}
function toggleInverseAspectRatio()
{
	cropInverseAspectRatio = !cropInverseAspectRatio;

	if (cropInverseAspectRatio) {
		minWidth = divHeight;
		minHeight = divWidth;

		if (originalWidth > originalHeight) {
			maxWidth = Math.floor(originalHeight / aspectX * aspectY);
			maxHeight = originalHeight;
		} else {
			maxWidth = originalWidth;
			maxHeight = Math.floor(originalWidth / aspectY * aspectX);
		}
	} else {
		minWidth = divWidth;
		maxWidth = originalWidth;

		minHeight = divHeight;
		maxHeight = originalHeight;
	}

	var x = aspectX;
	var y = aspectY;
	aspectX = y;
	aspectY = x;

	if (originalWidth > originalHeight)
		setCropHeight(cropWidth);
	else
		setCropWidth(cropHeight);

	if (cropped) {
		turnPhotoDiv(true);
		crop();
	}
}
function controlDivDrag(event)
{
	controlDiv.style.left = (startX + event.clientX) + 'px';
	controlDiv.style.top = (startY + event.clientY) + 'px';
	return false;
}
function startControlDivDrag(event)
{
	if (isInputElement(event.target)) return true;
	startX = controlDiv.offsetLeft - event.clientX;
	startY = controlDiv.offsetTop - event.clientY;
	document.onmousemove = controlDivDrag;
	document.onmouseup = releaseElement;
	blurActiveElement();
	return false;
}
function isInputElement(element)
{
	return element instanceof HTMLInputElement
		|| element instanceof HTMLSelectElement
		|| element instanceof HTMLOptionElement;
}
function blurActiveElement()
{
	if (isInputElement(document.activeElement)) document.activeElement.blur();
}
function preventDefault(event)
{
	event.preventDefault();
	blurActiveElement();
}
function centerElement(element, top, left)
{
	if (top === undefined) {
		var displayHeight = document.documentElement.clientHeight;
		top = Math.round((displayHeight - element.clientHeight) / 2);
		if (top < 8) top = 8;
	}
	if (left === undefined) {
		var displayWidth = document.documentElement.clientWidth;
		left = Math.round((displayWidth - element.clientWidth) / 2);
		if (left < 8) left = 8;
	}
	element.style.top = top + "px";
	element.style.left = left + "px";
}
function showLoading(fileName)
{
	cropper.style.cursor = "wait";
	document.body.style.cursor = "wait";

	document.getElementById("spinDisc").style.animationPlayState = "running";

	var progressDiv = document.getElementById("progressDiv");
	progressDiv.style.left = "auto";
	progressDiv.firstChild.firstChild.nodeValue = "Loading " + fileName;
	progressDiv.style.display = "block";
	centerElement(progressDiv, 96);
}
function hideLoading()
{
	cropper.style.cursor = "move";
	document.body.style.cursor = "default";

	document.getElementById("progressDiv").style.display = "none";
	document.getElementById("spinDisc").style.animationPlayState = "paused";
}
function showFailed(errorMessage)
{
	var failedDiv = document.getElementById("failedDiv");
	failedDiv.style.left = "auto";
	failedDiv.firstChild.nodeValue = errorMessage;
	failedDiv.style.display = "block";
	centerElement(failedDiv, 22);
}
function hideFailed()
{
	document.getElementById("failedDiv").style.display = "none";
}
function imageLoaded(event)
{
	if (cropped) undo();
	else if (photo.src === "")
		disableCropElements(false);

	var isVideo = event.target instanceof HTMLVideoElement;
	var modeSelect = document.getElementById("modeSelect");
	if (isVideo) {
		if (svgMode) {
			modeSelect.selectedIndex = 4;
			changeMode();
		} else if (modeSelect.selectedIndex === 1) {
			modeSelect.selectedIndex = 3;
		} else if (modeSelect.selectedIndex === 2) {
			modeSelect.selectedIndex = 4;
		}
	} else {
		if (modeSelect.selectedIndex === 3)
			modeSelect.selectedIndex = 1;
		else if (modeSelect.selectedIndex === 4)
			modeSelect.selectedIndex = 2;
	}
	var options = modeSelect.options;
	for (var i = 0; i < options.length; ++i)
		options[i].disabled = ((options[i].value & ModeFlags.Video) === 0) === isVideo;

	var oldPhoto = photo;
	photo = event.target;

	photo.removeEventListener(isVideo ? "canplay" : "load", imageLoaded, false);
	photo.removeEventListener("error", imageFailedLoad, false);
	photo.style.position = "absolute";

	if (isVideo) {
		originalWidth = photo.videoWidth;
		originalHeight = photo.videoHeight;
	} else {
		originalWidth = photo.naturalWidth;
		originalHeight = photo.naturalHeight;
	}

	if (svgMode)
		svgImage.setAttributeNS(xlinkNS, "href", photo.src);
	else {
		oldPhoto.parentNode.replaceChild(photo, oldPhoto);
		photo.style.webkitFilter = oldPhoto.style.webkitFilter;
		photo.style.filter = oldPhoto.style.filter;
	}

	if (oldPhoto.src.substr(0, 5) === "blob:")
		URL.revokeObjectURL(oldPhoto.src);

	init();
	hideLoading();
	manageUserSpaceFilters();

	if (queryString.inverseAspectRatio) {
		queryString.inverseAspectRatio = false;
		var checkbox = document.getElementById("inverseAspectRatioCheckbox");
		if (!checkbox.disabled) {
			checkbox.checked = true;
			toggleInverseAspectRatio();
		}
	}
	if (queryString.cropGeometry) {
		var [w, h, x, y] = queryString.cropGeometry;
		queryString.cropGeometry = null;

		cropWidthField.value = w; changeCropWidth();
		cropXField.value = x; changeCropX();
		cropYField.value = y; changeCropY();
		crop();
	}
	if (queryString.rotateAngle !== 0) {
		rotatePhoto(queryString.rotateAngle);
		queryString.rotateAngle = 0;
	}
	if (queryString.overlayCanvas) {
		queryString.overlayCanvas = false;
		document.getElementById("overlayCanvasLink").click();
	}
}
function imageFailedLoad(event)
{
	hideLoading();

	if (queryString.crossOrigin) {
		queryString.crossOrigin = false;
		loadImage();
		return;
	}

	var fileNameField = document.getElementById("fileNameField");
	var selectedIndex = fileNameField.selectedIndex;

	showFailed("Failed to load " + imageNames[selectedIndex]);

	if (imageNames.length > 1) {
		imageNames.splice(selectedIndex, 1);
		if (imageFiles)
			imageFiles.splice(selectedIndex, 1);
	} else {
		imageNames = undefined;
		imageFiles = undefined;
	}

	fileNameField.remove(selectedIndex);
	loadImage();
}
function loadImage()
{
	var prevButton = document.getElementById("prevButton");
	var nextButton = document.getElementById("nextButton");
	if (imageNames === undefined)
	{
		prevButton.disabled = true;
		nextButton.disabled = true;
		downloadLink.style.display = "none";
		return;
	}
	var fileNameField = document.getElementById("fileNameField");
	if (fileNameField.options.length === 0)
	{
		for (var name of imageNames)
			fileNameField.add(new Option(name, name));
		if (queryString.selectedImage > 0) {
			fileNameField.selectedIndex = queryString.selectedImage;
			queryString.selectedImage = 0;
		} else
			fileNameField.selectedIndex = 0;
	}
	var selectedIndex = fileNameField.selectedIndex;
	prevButton.disabled = (selectedIndex === 0);
	nextButton.disabled = (selectedIndex === fileNameField.options.length - 1);

	var imageName = imageNames[selectedIndex];
	downloadLink.download = imageName;
	downloadLink.style.display = "inline";
	showLoading(imageName);

	var isVideo;
	if (imageFiles) {
		isVideo = imageFiles[selectedIndex].type.substr(0, 6) === "video/";
	} else {
		var i = imageName.lastIndexOf(".");
		isVideo = i > 0 && videoExtensions.indexOf(imageName.substr(i + 1).toLowerCase()) >= 0;
	}

	var imageObject;
	if (isVideo) {
		imageObject = document.createElement("video");
		imageObject.addEventListener("canplay", imageLoaded, false);
	} else {
		imageObject = new Image();
		imageObject.addEventListener("load", imageLoaded, false);
	}
	imageObject.addEventListener("error", imageFailedLoad, false);
	if (queryString.crossOrigin)
		imageObject.crossOrigin = "anonymous";
	if (imageFiles === undefined)
		imageObject.src = imagePath + imageName;
	else
		imageObject.src = URL.createObjectURL(imageFiles[selectedIndex]);
}
function prevImage()
{
	var fileNameField = document.getElementById("fileNameField");
	if (fileNameField.selectedIndex > 0)
		--fileNameField.selectedIndex;
	loadImage();
}
function nextImage()
{
	var fileNameField = document.getElementById("fileNameField");
	if (fileNameField.selectedIndex < fileNameField.options.length - 1)
		++fileNameField.selectedIndex;
	loadImage();
}
function drawCanvas()
{
	if (photo.src === "") return null;

	if (hiddenCanvas === undefined)
		hiddenCanvas = document.createElement("canvas");

	hiddenCanvas.width = divWidth;
	hiddenCanvas.height = divHeight;

	var context = hiddenCanvas.getContext("2d");

	if (cropped)
		context.drawImage(photo, +cropXField.value, +cropYField.value,
			cropWidth, cropHeight, 0, 0, divWidth, divHeight);
	else
		context.drawImage(photo, 0, 0, divWidth, divHeight);

	var imageData;
	try {
		imageData = context.getImageData(0, 0, divWidth, divHeight);
	} catch (exception) {
		if (exception instanceof DOMException && exception.name === 'SecurityError')
			showFailed(exception);
		else
			showFailed(exception);
		return null;
	}

	for (var filter of filters)
	{
		var option = filter.option;

		if (filter.value === option.noChangeValue || filter.channels === 0)
			continue;

		var amount = option.unit === '%' ? filter.value / 100 : filter.value;
		var info = option.ui.getInfo ? option.ui.getInfo(filter) : undefined;

		var name = filter.option.name;
		if (name === 'd-blur-x') {
			if (rotateAngle === 180 || rotateAngle === 90) amount = -amount;
		} else if (name === 'd-blur-y') {
			if (rotateAngle === 180 || rotateAngle === 270) amount = -amount;
		}

		imageData = option.applyFilter(context, imageData, amount, filter.channels, info);
	}

	context.putImageData(imageData, 0, 0);

	var canvas = document.getElementById("canvas");
	context = canvas.getContext("2d");

	if (rotateAngle === 0 || rotateAngle === 180) {
		canvas.width = divWidth;
		canvas.height = divHeight;
		if (rotateAngle === 180)
			context.setTransform(-1, 0, 0, -1, canvas.width, canvas.height);
	} else {
		canvas.width = divHeight;
		canvas.height = divWidth;
		if (rotateAngle === 90)
			context.setTransform(0, 1, -1, 0, canvas.width, 0);
		else
			context.setTransform(0, -1, 1, 0, 0, canvas.height); // rotateAngle === 270
	}

	context.drawImage(hiddenCanvas, 0, 0);
	return canvas;
}
function saveImage(event)
{
	if (downloadBlobURL) {
		if (downloadLinkReady) {
			downloadLinkReady = false;
			return;
		}
		if (downloadURL !== null)
			URL.revokeObjectURL(downloadURL);
	}

	var canvas = drawCanvas();
	if (canvas === null) {
		event.preventDefault();
		return;
	}

	if (downloadBlobURL && canvas.toBlob === undefined) // for Chrome and Safari
		downloadBlobURL = false;

	if (downloadBlobURL) {
		event.preventDefault();
		canvas.toBlob(function(blob) {
			downloadLink.href = downloadURL = URL.createObjectURL(blob);
			downloadLinkReady = true;
			downloadLink.click();
		}, downloadType, downloadQuality);
	} else {
		downloadLink.href = canvas.toDataURL(downloadType, downloadQuality);
	}
}
function overlayCanvas(event)
{
	event.preventDefault();

	var textNode = event.currentTarget.firstChild;

	if (textNode.nodeValue === "Hide Canvas") {
		document.getElementById("canvas").style.display = "none";
		controlDiv.style.display = "block";
		textNode.nodeValue = "Overlay Canvas";
		return;
	}

	var canvas = drawCanvas();
	if (canvas === null)
		return;

	canvas.style.left = photoDiv.offsetLeft + "px";
	canvas.style.top = photoDiv.offsetTop + "px";
	canvas.style.display = "block";
	controlDiv.style.display = "none";
	textNode.nodeValue = "Hide Canvas";
}
var standardUI = {
	create: function(filter, info)
	{
		var option = filter.option;
		var changeHandler = function(event) { changeFilterValue(filter, event); };
		var keydownHandler = function(event) { return handleSliderKeyDown(filter, event); };

		var sliderElement = document.createElement('INPUT');
		sliderElement.type = 'range';
		sliderElement.min = option.minValue;
		sliderElement.max = option.maxValue;
		sliderElement.value = option.defaultValue;
		sliderElement.addEventListener('change', changeHandler, false);
		sliderElement.addEventListener('keydown', keydownHandler, false);

		var inputElement = document.createElement('INPUT');
		inputElement.type = 'text';
		inputElement.size = 4;
		inputElement.maxLength = 4;
		inputElement.value = option.defaultValue;
		inputElement.addEventListener('change', changeHandler, false);

		var div = filter.uiDiv;
		div.appendChild(sliderElement);
		div.appendChild(inputElement);
		div.appendChild(document.createTextNode(option.unit));

		filter.value = option.defaultValue;
		filter.sliderElement = sliderElement;
		filter.inputElement = inputElement;

		if (info === undefined) return;

		var value = parseInt(info.value, 10);
		if (isNaN(value) || value != info.value || value === option.defaultValue
			|| value < option.minValue
			|| value > option.maxValue) return;

		sliderElement.value = value;
		inputElement.value = value;
		filter.value = value;
	},
	remove: function(filter)
	{
		var div = filter.uiDiv;
		while (div.firstChild)
			div.removeChild(div.firstChild);

		delete filter.sliderElement;
		delete filter.inputElement;
	},
	setDefault: function(filter)
	{
		var option = filter.option;
		filter.sliderElement.min = option.minValue;
		filter.sliderElement.max = option.maxValue;

		filter.value = option.defaultValue;
		filter.sliderElement.value = filter.value;
		filter.inputElement.value = filter.value;
		filter.inputElement.nextSibling.nodeValue = option.unit;
	},
	setValueForURL: function(filter, infoList)
	{
		if (filter.value !== filter.option.defaultValue)
			infoList.push(filter.value);
	}
};
var blurUI = {
	create: function(filter, info)
	{
		standardUI.create(filter, info);
		this._createFromStandard(filter, info);
	},
	remove: function(filter)
	{
		this._revertToStandard(filter);
		standardUI.remove(filter);
	},
	_createFromStandard: function(filter, info)
	{
		var edgeSelect = document.createElement('SELECT');
		edgeSelect.add(new Option('duplicate', 'duplicate', true, true));
		edgeSelect.add(new Option('wrap', 'wrap'));
		edgeSelect.add(new Option('black', 'none'));
		edgeSelect.add(new Option('mirror', 'mirror'));
		edgeSelect.addEventListener('change', function(event) {
			filter.edgeMode = edgeSelect.options[edgeSelect.selectedIndex];
			manageFilters(filter);
		}, false);

		var div = filter.uiDiv;
		div.appendChild(document.createElement('BR'));
		div.appendChild(document.createTextNode('Edge Mode:'));
		div.appendChild(edgeSelect);
		div.className = 'uiDiv uiDivBlur';
		div.parentNode.className = 'ui2';

		filter.edgeMode = edgeSelect.options[0];

		if (info === undefined) return;

		var edgeMode = parseInt(info.extraValue, 10);
		if (!isNaN(edgeMode) && edgeMode == info.extraValue && edgeMode > 0 && edgeMode <= 3) {
			edgeSelect.selectedIndex = edgeMode;
			filter.edgeMode = edgeSelect.options[edgeMode];
		}
	},
	createFromStandard: function(filter)
	{
		standardUI.setDefault(filter);
		this._createFromStandard(filter);
	},
	_revertToStandard: function(filter)
	{
		var div = filter.uiDiv;
		div.removeChild(div.lastChild);
		div.removeChild(div.lastChild);
		div.removeChild(div.lastChild);
		div.className = 'uiDiv';
		div.parentNode.className = 'ui1';

		delete filter.edgeMode;
	},
	revertToStandard: function(filter)
	{
		this._revertToStandard(filter);
		standardUI.setDefault(filter);
	},
	setDefault: function(filter)
	{
		standardUI.setDefault(filter);
	},
	setValueForURL: function(filter, infoList)
	{
		var name = filter.option.name;
		var changeSign = false;
		if (name === 'd-blur-x') {
			if (rotateAngle === 180 || rotateAngle === 90) changeSign = true;
		} else if (name === 'd-blur-y') {
			if (rotateAngle === 180 || rotateAngle === 270) changeSign = true;
		}
		var value = changeSign ? -filter.value : filter.value;

		if (!filter.edgeMode.defaultSelected) {
			infoList.push(value);
			infoList.push(filter.edgeMode.index);
		} else if (value !== 0)
			infoList.push(value);
	},
	getInfo: function(filter)
	{
		return filter.edgeMode.value;
	}
};
var polarUI = {
	create: function(filter, info)
	{
		var radiusSelect = document.createElement('SELECT');
		radiusSelect.add(new Option('diagonal/2', '0', true, true));
		radiusSelect.add(new Option('width/2', '1'));
		radiusSelect.add(new Option('height/2', '2'));
		radiusSelect.add(new Option('height', '3'));
		radiusSelect.addEventListener('change', function(event) {
			filter.value = radiusSelect.selectedIndex;
			manageFilters(filter);
		}, false);

		var edgeSelect = document.createElement('SELECT');
		edgeSelect.add(new Option('duplicate', '0', true, true));
		edgeSelect.add(new Option('black', '1'));
		edgeSelect.add(new Option('transparent', '2'));
		edgeSelect.addEventListener('change', function(event) {
			filter.edgeMode = edgeSelect.selectedIndex;
		}, false);

		var div = filter.uiDiv;
		div.appendChild(document.createTextNode('Radius:'));
		div.appendChild(radiusSelect);
		div.appendChild(document.createElement('BR'));
		div.appendChild(document.createTextNode('Edge Mode:'));
		div.appendChild(edgeSelect);
		div.className = 'uiDiv uiDivPolar';
		div.parentNode.className = 'ui2';

		filter.value = 0;
		filter.edgeMode = 0;

		if (info !== undefined) {
			var value = parseInt(info.value, 10);
			if (!isNaN(value) && value == info.value && value > 0 && value <= 3) {
				radiusSelect.selectedIndex = value;
				filter.value = value;
			}
			var edgeMode = parseInt(info.extraValue, 10);
			if (!isNaN(edgeMode) && edgeMode == info.extraValue && edgeMode > 0 && edgeMode <= 2) {
				edgeSelect.selectedIndex = edgeMode;
				filter.edgeMode = edgeMode;
			}
		}
	},
	remove: function(filter)
	{
		var div = filter.uiDiv;
		while (div.firstChild)
			div.removeChild(div.firstChild);

		div.className = 'uiDiv';
		div.parentNode.className = 'ui1';

		delete filter.edgeMode;
	},
	createFromStandard: function(filter)
	{
		standardUI.remove(filter);
		this.create(filter);
	},
	revertToStandard: function(filter)
	{
		this.remove(filter);
		standardUI.create(filter);
	},
	setDefault: function(filter)
	{
	},
	setValueForURL: function(filter, infoList)
	{
		if (filter.edgeMode !== 0) {
			infoList.push(filter.value);
			infoList.push(filter.edgeMode);
		} else if (filter.value !== 0)
			infoList.push(filter.value);
	},
	getInfo: function(filter)
	{
		return filter.edgeMode;
	}
};
var convolveUI = {
	showInfo: function(event)
	{
		event.preventDefault();
		var div = document.getElementById('convolveInfoDiv');
		div.style.display = 'block';
		centerElement(div);
	},
	hideInfo: function()
	{
		document.getElementById('convolveInfoDiv').style.display = 'none';
	},
	create: function(filter, info)
	{
		var opSelect = document.createElement('SELECT');
		opSelect.add(new Option('none', 'none', true, true));
		for (var c of Convolutions)
			opSelect.add(new Option(c.name, c.name));

		var infoLink = document.createElement('A');
		infoLink.href = '#';
		infoLink.appendChild(document.createTextNode('?'));
		infoLink.addEventListener('click', this.showInfo, false);

		var span = document.createElement('SPAN');
		span.appendChild(document.createTextNode('|\u0192|')); // &fnof;
		span.className = 'convAbs convAbsOff';
		span.style.display = 'none';
		span.addEventListener('click', function(event) {
			filter.useAbsoluteValue = !filter.useAbsoluteValue;
			span.className = 'convAbs convAbs' + (filter.useAbsoluteValue ? 'On' : 'Off');
			manageFilters(filter);
		}, false);

		opSelect.addEventListener('change', function(event) {
			filter.value = opSelect.selectedIndex;
			if (filter.value > 0 && Convolutions[filter.value - 1].allowAbs) {
				span.style.display = 'inline';
			} else {
				span.className = 'convAbs convAbsOff';
				span.style.display = 'none';
				filter.useAbsoluteValue = false;
			}
			manageFilters(filter);
		}, false);

		var div = filter.uiDiv;
		div.appendChild(opSelect);
		div.appendChild(infoLink);
		div.appendChild(span);
		div.className = 'uiDiv uiDivConvolve';
		div.parentNode.className = 'ui2';

		filter.value = 0;
		filter.useAbsoluteValue = false;

		if (info === undefined) return;

		var value = parseInt(info.value, 10);

		if (isNaN(value) || value != info.value || value <= 0 || value > Convolutions.length) return;

		opSelect.selectedIndex = value;
		filter.value = value;

		if (!Convolutions[value - 1].allowAbs) return;

		span.style.display = 'inline';

		if (info.extraValue !== '1') return;

		span.className = 'convAbs convAbsOn';
		filter.useAbsoluteValue = true;
	},
	remove: function(filter)
	{
		var div = filter.uiDiv;
		while (div.firstChild)
			div.removeChild(div.firstChild);

		div.className = 'uiDiv';
		div.parentNode.className = 'ui1';
	},
	createFromStandard: function(filter)
	{
		standardUI.remove(filter);
		this.create(filter);
	},
	revertToStandard: function(filter)
	{
		this.remove(filter);
		standardUI.create(filter);
	},
	setDefault: function(filter)
	{
	},
	setValueForURL: function(filter, infoList)
	{
		if (filter.useAbsoluteValue) {
			infoList.push(filter.value);
			infoList.push(1);
		} else if (filter.value !== 0)
			infoList.push(filter.value);
	},
	getInfo: function(filter)
	{
		return filter.useAbsoluteValue;
	}
};
function FilterOption(name, unit, defaultValue, minValue, maxValue, applyFilter, svgOnly, createSVGFilter)
{
	this.name = name;
	this.unit = unit;
	this.defaultValue = defaultValue;
	this.noChangeValue = defaultValue;
	this.ui = standardUI;
	this.minValue = minValue;
	this.maxValue = maxValue;
	this.applyFilter = applyFilter;
	this.svgOnly = svgOnly;
	this.createSVGFilter = createSVGFilter;
}
function simpleFilter(applyFilter)
{
	return function(context, imageData, amount, channels) {
		applyFilter(imageData.data, amount, channels);
		return imageData;
	}
}
var filterOptions = [
new FilterOption('brightness', '%',   100, 0, 2000, simpleFilter(applyBrightnessFilter), false, createSVGBrightness),
new FilterOption('contrast',   '%',   100, 0,  800, simpleFilter(applyContrastFilter),   false, createSVGContrast),
new FilterOption('saturate',   '%',   100, 0, 1000, simpleFilter(applySaturateFilter),   false, createSVGSaturate),
new FilterOption('grayscale',  '%',     0, 0,  100, simpleFilter(applyGrayscaleFilter),  false, createSVGGrayscale),
new FilterOption('sepia',      '%',     0, 0,  100, simpleFilter(applySepiaFilter),      false, createSVGSepia),
new FilterOption('hue-rotate', 'deg',   0, 0,  360, simpleFilter(applyHueRotateFilter),  false, createSVGHueRotate),
new FilterOption('threshold',  '',    128, 0,  256, simpleFilter(applyThreshold),        true,  createSVGThreshold),
new FilterOption('invert',     '%',     0, 0,  100, simpleFilter(applyInvertFilter),     false, createSVGInvert),
new FilterOption('convolve',   '',      0, 0,   12, applyConvolution,                    true,  createSVGConvolve),
new FilterOption('tilt-shift', 'px',    0, 0,   20, applyTiltShift,                      true,  createTiltShift),
new FilterOption('blur',       'px',    0, 0,   20, applyBlurFilter,                     true,  createBlurFilter),
new FilterOption('blur-x',     'px',    0, 0,   40, applyBlurXFilter,                    true,  createBlurXFilter),
new FilterOption('blur-y',     'px',    0, 0,   40, applyBlurYFilter,                    true,  createBlurYFilter),
new FilterOption('d-blur-x',   'px',    0,-40,  40, applyDBlurX,                         true,  createSVGDBlurX),
new FilterOption('d-blur-y',   'px',    0,-40,  40, applyDBlurY,                         true,  createSVGDBlurY),
new FilterOption('polar',      '',      0, 0,    3, applyPolarTransform,                 true,  createSVGPolar),
new FilterOption('depolar',    '',      0, 0,    3, applyReversePolarTransform,          true,  createSVGReversePolar),
];
function Filter(tableCell, info)
{
	this.selectElement = tableCell.firstChild;
	this.tableRow = tableCell.parentNode;
	this.uiDiv = tableCell.lastChild;
	this.option = filterOptions[this.selectElement.selectedIndex];
	this.option.ui.create(this, info);
	this.channels = info.channels;
	this.manage = true;
	this.id = 0;
}
function swapXYFilters(angle)
{
	for (var option of filterOptions)
	{
		var name = option.name;
		if (name.substr(-2) === '-x') {
			var swapName = name.substr(0, name.length - 1) + 'y';
			option.swapIndex = filterIndex[swapName];

			var swapOption = filterOptions[option.swapIndex];
			swapOption.swapIndex = filterIndex[name];

			var fn = option.createSVGFilter;
			option.createSVGFilter = swapOption.createSVGFilter;
			swapOption.createSVGFilter = fn;

			fn = option.applyFilter;
			option.applyFilter = swapOption.applyFilter;
			swapOption.applyFilter = fn;
		}
		else if (name.substr(-2) !== '-y')
			option.swapIndex = null;
	}
	for (var filter of filters)
		if (filter.option.swapIndex !== null)
		{
			var name = filter.option.name;
			var changeSign = false;
			if (name === 'd-blur-x') {
				if (angle === 270) changeSign = true;
			} else if (name === 'd-blur-y') {
				if (angle === 90) changeSign = true;
			}
			if (changeSign) {
				filter.value = -filter.value;
				filter.sliderElement.value = filter.value;
				filter.inputElement.value = filter.value;
			}
			filter.selectElement.selectedIndex = filter.option.swapIndex;
			filter.option = filterOptions[filter.option.swapIndex];
		}
}
function reverseLRFilters()
{
	for (var filter of filters)
	{
		var name = filter.option.name;
		if (name === 'd-blur-x' || name === 'd-blur-y') {
			filter.value = -filter.value;
			filter.sliderElement.value = filter.value;
			filter.inputElement.value = filter.value;
		}
	}
}
function markupFilterStyle(inData)
{
	var outData = '';

	var k, i = 0;
	while (i < inData.length)
	{
		k = inData.indexOf('(', i);
		if (k < 0) { outData += inData.substr(i); break; }
		outData += '<span class="cA">' + inData.substr(i, k - i) + '</span>(';
		i = k + 1;
		k = inData.indexOf(')', i);
		if (k < 0) { outData += inData.substr(i); break; }
		outData += '<span class="cV">' + inData.substr(i, k - i) + '</span>)';
		i = k + 1;
	}

	return outData;
}
function markupTag(inData)
{
	var k = inData.indexOf(' ');
	var tag = k < 0 ? inData : inData.substr(0, k);
	var outData = '<span class="cT">' + tag + '</span>';

	var v;
	var dataPrefix = 'data:image/png;base64,';
	var dataPrefixLen = dataPrefix.length;

	var i = tag.length + 1;
	while (i < inData.length)
	{
		k = inData.indexOf('=', i);
		outData += ' <span class="cA">' + inData.substr(i, k - i) + '</span>';
		i = k + 2;
		k = inData.indexOf('"', i);
		if (k - i > dataPrefixLen && inData.substr(i, dataPrefixLen) === dataPrefix)
			v = dataPrefix + '&hellip;';
		else
			v = inData.substr(i, k - i);
		outData += '=&quot;<span class="cV">' + v + '</span>&quot;';
		i = k + 2;
	}

	return [tag, outData];
}
function getURL()
{
	var filterList = [];
	for (var filter of filters)
	{
		var option = filter.option;
		var channels = filter.channels;

		var rgb = '';
		if ((channels & 1) !== 0) rgb += 'r';
		if ((channels & 2) !== 0) rgb += 'g';
		if ((channels & 4) !== 0) rgb += 'b';

		// When creating filters from the query string, the rotation angle will be 0.
		// The rotation angle from the query string won't be applied until after the
		// image is loaded. So if we're currently rotated 90 or 270 degrees, we have
		// to swap the names of filters like blur-x and blur-y in the query string so
		// they'll be swapped back to their current values after the image is loaded.

		if ((rotateAngle === 90 || rotateAngle === 270) && option.swapIndex !== null)
			option = filterOptions[option.swapIndex];

		var infoList = [option.name, rgb];

		option.ui.setValueForURL(filter, infoList);

		if (infoList.length === 2 && rgb === 'rgb')
			filterList.push(option.name);
		else
			filterList.push(infoList.join(','));
	}

	var url = window.location;

	url = url.protocol + '//' + url.host + url.pathname;
	url += '?f=' + filterList.join('/');
	if (imageFiles === undefined) {
		if (cropped)
			url += '&c=' + cropWidth + 'x' + cropHeight + '+'
				+ cropXField.value + '+' + cropYField.value;
		if (rotateAngle !== 0)
			url += '&r=' + rotateAngle;
		if (cropInverseAspectRatio)
			url += '&iar';
		url += '&i=' + document.getElementById('fileNameField').value;
	}
	return url;
}
function showFilterCode(event)
{
	event.preventDefault();

	var filterStyle = markupFilterStyle(photo.style.webkitFilter || 'none');

	var css = '<span class="cT">-webkit-filter</span>: ' + filterStyle +
		';\n<span class="cT">filter</span>: ' + filterStyle + ';\n';

	var svgRoot = document.getElementById('svgRoot');
	var svg = 'svg';
	for (var name of ['width', 'height', 'viewBox', 'xmlns', 'xmlns:xlink'])
		if (svgRoot.hasAttribute(name))
			svg += ' ' + name + '="' + svgRoot.getAttribute(name) + '"';
	svg = '&lt;' + markupTag(svg)[1] + '&gt;';

	var j = 0;
	var indent = 0;
	var previousTag = null;
	var html = svgRoot.innerHTML;

	while ((j = html.indexOf('<', j)) >= 0)
	{
		var endTag = html.charAt(j + 1) === '/';
		var k = endTag ? j + 2 : j + 1;

		j = html.indexOf('>', k);
		var [tag, tagData] = markupTag(html.substr(k, j - k));

		if (endTag) {
			--indent;
			if  (tag !== previousTag) {
				svg += '\n';
				for (k = 0; k < indent; ++k) svg += '  ';
			}
			svg += '&lt;/' + tagData + '&gt;';
			previousTag = null;
		} else {
			svg += '\n';
			for (k = 0; k < indent; ++k) svg += '  ';
			svg += '&lt;' + tagData + '&gt;';
			previousTag = tag;
			++indent;
		}
	}

	svg += '\n&lt;/' + markupTag('svg')[1] + '&gt;\n';

	var urlCode = document.getElementById("urlCode");
	var cssCode = document.getElementById("cssCode");
	var svgCode = document.getElementById("svgCode");

	urlCode.style.width = 'auto';
	urlCode.style.height = 'auto';
	cssCode.style.width = 'auto';
	cssCode.style.height = 'auto';
	svgCode.style.width = 'auto';
	svgCode.style.height = 'auto';

	urlCode.innerHTML = getURL();
	cssCode.innerHTML = css;
	svgCode.innerHTML = svg;

	var filterCodeDiv = document.getElementById("filterCodeDiv");
	filterCodeDiv.style.display = "block";

	if (urlCode.clientWidth > 880)
		// Add a blank line so the horizontal scroll bar doesn't cover the URL when scrolling.
		urlCode.innerHTML += '\n\n';

	var width = Math.min(880, Math.max(
		urlCode.clientWidth,
		cssCode.clientWidth,
		svgCode.clientWidth)) + 'px';

	urlCode.style.width = width;
	cssCode.style.width = width;
	svgCode.style.width = width;
	if (svgCode.clientHeight > 450) svgCode.style.height = '450px';

	centerElement(filterCodeDiv);
}
function hideFilterCode()
{
	document.getElementById("filterCodeDiv").style.display = "none";
}
function applyFiltersSVG()
{
	prevFilterId = 0;
	for (var filter of filters)
	{
		if (filter.manage)
			manageFilter(filter);
		if (filter.id > 0)
			prevFilterId = filter.id;
	}
	var filter = prevFilterId > 0 ? 'url(#' + svgFilter.id + ')' : 'none';
	if (svgMode) {
		if (!svgImage) return;
		if (prevFilterId > 0)
			svgImage.setAttribute('filter', filter);
		else
			svgImage.removeAttribute('filter');
	} else {
		photo.style.webkitFilter = filter;
		photo.style.filter = filter;
	}
}
function applyFiltersHTML()
{
	var filterList = [];
	for (var filter of filters)
	{
		var option = filter.option;
		if (filter.manage)
			manageFilter(filter);
		if (filter.id === 0)
			filterList.push(option.name + '(' + filter.value + option.unit + ')');
		else if (filter.id > 0)
			filterList.push('url(#filter' + filter.id + ')');
	}
	var filterStyle = filterList.length === 0 ? 'none' : filterList.join(' ');
	photo.style.webkitFilter = filterStyle;
	photo.style.filter = filterStyle;
}
var applyFilters = singleFilter ? applyFiltersSVG : applyFiltersHTML;
function manageFilter(filter)
{
	var option = filter.option;
	if (filter.id > 0)
		removeSVGFilter(filter.id);
	if (filter.value === option.noChangeValue || filter.channels === 0) {
		filter.id = -1;
	} else if (singleFilter || option.svgOnly || filter.channels < 7) {
		var amount = option.unit === '%' ? filter.value / 100 : filter.value;
		var info = option.ui.getInfo ? option.ui.getInfo(filter) : undefined;

		filter.id = option.createSVGFilter(amount, filter.channels, info);
	} else {
		filter.id = 0;
	}
	filter.manage = false;
}
function manageFilters(filter)
{
	filter.manage = true;
	applyFilters();
}
function toggleSingleFilter()
{
	for (var filter of filters)
	{
		if (filter.id > 0)
			removeSVGFilter(filter.id);
		filter.id = 0;
		filter.manage = true;
	}

	singleFilter = !singleFilter;
	applyFilters = singleFilter ? applyFiltersSVG : applyFiltersHTML;
}
function replaceHTMLImgWithSVGImage()
{
	var photoLoaded = (photo.src !== "");

	var svgRoot = document.getElementById('svgRoot');

	svgImage = document.createElementNS(svgNS, 'image');
	if (photoLoaded) {
		svgImage.setAttributeNS(xlinkNS, 'href', photo.src);
		svgImage.setAttribute('width', photo.offsetWidth);
		svgImage.setAttribute('height', photo.offsetHeight);
	}

	svgRoot.appendChild(svgImage);
	photo.parentNode.replaceChild(svgRoot, photo);

	if (photoLoaded) {
		svgRoot.setAttribute('width', divWidth);
		svgRoot.setAttribute('height', divHeight);
		svgRoot.setAttribute('viewBox', [0, 0, divWidth, divHeight].join(' '));
		transformPhoto();
		svgRoot.style.cursor = photo.style.cursor;
		svgRoot.onmousedown = photo.onmousedown;

		photo.style.left = '0px';
		photo.style.top = '0px';
		photo.style.width = divWidth + 'px';
		photo.style.height = divHeight + 'px';
		photo.style.transform = 'none';
		photo.style.cursor = 'default';
		photo.onmousedown = null;
	}

	photo.style.webkitFilter = 'none';
	photo.style.filter = 'none';
}
function replaceSVGImageWithHTMLImg()
{
	var svgRoot = svgImage.parentNode;
	svgRoot.parentNode.replaceChild(photo, svgRoot);

	if (photo.src !== "") {
		photo.style.width = svgImage.getAttribute('width') + 'px';
		photo.style.height = svgImage.getAttribute('height') + 'px';
		transformPhoto();
		photo.style.cursor = svgRoot.style.cursor;
		photo.onmousedown = svgRoot.onmousedown;

		svgRoot.setAttribute('width', 0);
		svgRoot.setAttribute('height', 0);
		svgRoot.removeAttribute('viewBox');
		svgRoot.style.transform = 'none';
		svgRoot.style.cursor = 'default';
		svgRoot.onmousedown = null;
	}

	svgRoot.removeChild(svgImage);
	document.body.appendChild(svgRoot);
}
function changeMode()
{
	var mode = +document.getElementById('modeSelect').value;

	var _svgMode = (mode & ModeFlags.SVGImage) !== 0;
	var _singleFilter = (mode & ModeFlags.SingleFilter) !== 0;

	if (svgMode !== _svgMode) {
		svgMode = _svgMode;
		if (svgMode)
			replaceHTMLImgWithSVGImage();
		else
			replaceSVGImageWithHTMLImg();
		if (singleFilter && _singleFilter && filterMarginX !== undefined)
			updateUserSpaceFilters();
	}
	if (singleFilter !== _singleFilter)
		toggleSingleFilter();
	applyFilters();
}
function changeFilterName(event)
{
	var selectElement = event.currentTarget;
	var tableRow = selectElement.parentNode.parentNode;

	var filter = filters[parseInt(tableRow.id.substr(9), 10)];
	var option = filterOptions[selectElement.selectedIndex];

	var oldUI = filter.option.ui;
	var newUI = option.ui;

	filter.option = option;

	if (oldUI === newUI)
		newUI.setDefault(filter);
	else if (oldUI === standardUI)
		newUI.createFromStandard(filter);
	else if (newUI === standardUI)
		oldUI.revertToStandard(filter);
	else {
		oldUI.remove(filter);
		newUI.create(filter);
	}

	manageFilters(filter);
}
function changeFilterValue(filter, event)
{
	var inputElement = event.currentTarget;
	var option = filter.option;
	var value = parseInt(inputElement.value, 10);

	if (isNaN(value) || value != inputElement.value || value < option.minValue || value > option.maxValue) {
		inputElement.value = filter.value;
	} else if (value != filter.value) {
		filter.value = value;
		if (inputElement === filter.sliderElement)
			filter.inputElement.value = value;
		else
			filter.sliderElement.value = value;
		manageFilters(filter);
	}
}
function handleSliderKeyDown(filter, event)
{
	var key = event.key || event.keyIdentifier;
	if (key === 'Tab' || key === 'U+0009')
		return true;

	event.preventDefault();
	event.stopPropagation();

	var option = filter.option;
	var value = filter.value;
	var step = Math.min(10, Math.max(1, Math.floor((option.maxValue - option.minValue) / 20)));

	if (key === 'ArrowLeft' || key === 'Left') {
		if (value === option.minValue)
			return false;
		value -= step;
		if (value < option.minValue)
			value = option.minValue;
	} else if (key === 'ArrowRight' || key === 'Right') {
		if (value === option.maxValue)
			return false;
		value += step;
		if (value > option.maxValue)
			value = option.maxValue;
	} else
		return false;

	filter.value = value;
	filter.inputElement.value = value;
	filter.sliderElement.value = value;

	manageFilters(filter);
	return false;
}
function addFilterRowBefore(event)
{
	var span = event.currentTarget;
	var tableRow = span.parentNode.parentNode;
	var rowNumber = parseInt(tableRow.id.substr(9), 10); // e.g. filterRow0

	if (rowNumber === 0) // Remove +
	{
		var firstCell = tableRow.firstChild;
		firstCell.replaceChild(createEmptyText(), firstCell.firstChild);
	}
	if (filters.length === 1) // Add X
	{
		var lastCell = tableRow.lastChild;
		lastCell.replaceChild(createXMarkAfter(), lastCell.firstChild);
	}

	for (var i = filters.length - 1; i >= rowNumber; --i)
	{
		filters[i].tableRow.id = 'filterRow' + (i + 1);
		filters[i + 1] = filters[i];
	}

	var newRow = createFilterRow(rowNumber);
	tableRow.parentNode.insertBefore(newRow, tableRow);
}
function addFilterRowAfter(event)
{
	var span = event.currentTarget;
	var tableRow = span.parentNode.parentNode;
	var rowNumber = parseInt(tableRow.id.substr(9), 10); // e.g. filterRow0

	if (filters.length === 1) // Add X
	{
		var lastCell = tableRow.lastChild;
		lastCell.replaceChild(createXMarkAfter(), lastCell.firstChild);
	}

	for (var i = filters.length - 1; i > rowNumber; --i)
	{
		filters[i].tableRow.id = 'filterRow' + (i + 1);
		filters[i + 1] = filters[i];
	}

	var newRow = createFilterRow(rowNumber + 1);
	tableRow.parentNode.insertBefore(newRow, tableRow.nextSibling);
}
function removeFilterRow(event)
{
	var span = event.currentTarget;
	var tableRow = span.parentNode.parentNode;
	var rowNumber = parseInt(tableRow.id.substr(9), 10); // e.g. filterRow0

	tableRow.parentNode.removeChild(tableRow);

	var filterId = filters[rowNumber].id;
	if (filterId > 0)
		removeSVGFilter(filterId);

	for (var i = rowNumber; i < filters.length - 1; ++i)
	{
		filters[i] = filters[i + 1];
		filters[i].tableRow.id = 'filterRow' + i;
	}

	filters.length -= 1;

	if (filters.length === 1) // Remove X
	{
		var lastCell = filters[0].tableRow.lastChild;
		lastCell.replaceChild(createEmptyText(), lastCell.firstChild);
	}
	if (rowNumber === 0) // Add +
	{
		var firstCell = filters[0].tableRow.firstChild;
		firstCell.replaceChild(createPlusBefore(), firstCell.firstChild);
	}

	applyFilters();
}
function selectChannel(event)
{
	var span = event.currentTarget;
	var tableRow = span.parentNode.parentNode;
	var channel = span.firstChild.nodeValue;

	var filter = filters[parseInt(tableRow.id.substr(9), 10)]; // e.g. filterRow0
	var flag = channel === 'R' ? 1 : channel === 'G' ? 2 : 4;

	if ((filter.channels & flag) === 0) {
		filter.channels += flag;
		span.className = 'channelOn channel' + channel;
	} else {
		filter.channels -= flag;
		span.className = 'channelOff';
	}

	manageFilters(filter);
}
function createChannelSelector(tableCell, channel, on)
{
	var span = document.createElement('SPAN');
	span.className = on ? 'channelOn channel' + channel : 'channelOff';
	span.appendChild(document.createTextNode(channel));
	span.addEventListener('click', selectChannel, false);
	tableCell.appendChild(span);
}
function createClickableText(text, clickHandler)
{
	var span = document.createElement('SPAN');
	span.appendChild(document.createTextNode(text));
	span.className = 'clickable';
	span.addEventListener('click', clickHandler, false);
	return span;
}
function createPlusBefore()
{
	return createClickableText('+', addFilterRowBefore);
}
function createPlusAfter()
{
	return createClickableText('+', addFilterRowAfter);
}
function createXMarkAfter()
{
	return createClickableText('\u00D7', removeFilterRow);
}
function createEmptyText()
{
	return document.createTextNode('\u00A0');
}
function addFilterCell(tableRow, cellChild)
{
	var tableCell = document.createElement('TD');
	tableCell.appendChild(cellChild);
	tableRow.appendChild(tableCell);
}
function createFilterRow(rowNumber, info)
{
	if (info === undefined)
		info = {name: 'contrast', channels: 7};

	var tableRow = document.createElement('TR');
	tableRow.id = 'filterRow' + rowNumber;

	if (rowNumber === 0)
		addFilterCell(tableRow, createPlusBefore());
	else
		addFilterCell(tableRow, createEmptyText());

	var selectElement = document.createElement('SELECT');
	for (var option of filterOptions)
		selectElement.add(new Option(option.name, option.name));

	selectElement.selectedIndex = filterIndex[info.name];
	selectElement.addEventListener('change', changeFilterName, false);

	var uiDiv = document.createElement('DIV');
	uiDiv.className = 'uiDiv';

	var tableCell = document.createElement('TD');
	tableCell.appendChild(selectElement);
	createChannelSelector(tableCell, 'R', (info.channels & 1) !== 0);
	createChannelSelector(tableCell, 'G', (info.channels & 2) !== 0);
	createChannelSelector(tableCell, 'B', (info.channels & 4) !== 0);
	tableCell.appendChild(uiDiv);
	tableCell.className = 'ui1';
	tableRow.appendChild(tableCell);

	filters[rowNumber] = new Filter(tableCell, info);

	addFilterCell(tableRow, createPlusAfter());
	if (filters.length === 1)
		addFilterCell(tableRow, createEmptyText());
	else
		addFilterCell(tableRow, createXMarkAfter());

	return tableRow;
}
function parseCropGeometry(v)
{
	var i, j, s, n, g = [];

	if ((i = v.indexOf('x')) < 0) return;
	s = v.substr(0, i);
	n = parseInt(s, 10);
	if (isNaN(n) || n != s || n <= 0) return;
	g.push(n);

	if ((j = v.indexOf('+', ++i)) < 0) return;
	s = v.substr(i, j-i);
	n = parseInt(s, 10);
	if (isNaN(n) || n != s || n <= 0) return;
	g.push(n);

	if ((i = v.indexOf('+', ++j)) < 0) return;
	s = v.substr(j, i-j);
	n = parseInt(s, 10);
	if (isNaN(n) || n != s || n < 0) return;
	g.push(n);

	s = v.substr(i+1);
	n = parseInt(s, 10);
	if (isNaN(n) || n != s || n < 0) return;
	g.push(n);

	queryString.cropGeometry = g;
}
function parseQueryString()
{
	queryString = {
		filters: null,
		overlayCanvas: false,
		selectedImage: 0,
		cropGeometry: null,
		rotateAngle: 0,
		inverseAspectRatio: false,
		crossOrigin: false,
	};

	var q = window.location.search;

	if (typeof q !== 'string' || q.charAt(0) !== '?') return;

	for (var s of q.substr(1).split('&'))
	{
		if (s === 'o') {
			queryString.overlayCanvas = true;
			continue;
		}
		if (s === 'iar') {
			queryString.inverseAspectRatio = true;
			continue;
		}
		if (s === 'cors') {
			queryString.crossOrigin = true;
			continue;
		}
		var i = s.indexOf('=');
		if (i < 1 || i === s.length - 1) continue;
		var k = s.substr(0, i);
		var v = s.substr(i + 1);

		if (k === 'c')
			parseCropGeometry(v);

		else if (k === 'f')
			queryString.filters = v;

		else if (k === 'i') {
			if (imageNames !== undefined) {
				i = imageNames.indexOf(v);
				if (i >= 0) {
					queryString.selectedImage = i;
					continue;
				}
			}
			imagePath = '';
			imageNames = [v];
		}
		else if (k === 'r') {
			if (v === '90' || v === '180' || v === '270')
				queryString.rotateAngle = +v;
		}
	}
}
function createFiltersFromQueryString()
{
	if (queryString.filters === null) return;

	var filterList = [];
	for (var s of queryString.filters.split('/'))
	{
		var [name, rgb, value, extraValue] = s.split(',', 4);

		if (!filterIndex.hasOwnProperty(name)) continue;

		var channels;
		if (rgb === undefined)
			channels = 7;
		else {
			channels = 0;
			for (var c of rgb.toUpperCase())
				if (c === 'R') channels |= 1;
				else if (c === 'G') channels |= 2;
				else if (c === 'B') channels |= 4;
		}

		filterList.push({name: name, channels: channels, value: value, extraValue: extraValue});
	}

	if (filterList.length === 0) return;

	var tableRow = createFilterRow(0, filterList[0]);
	var table = document.createElement('TABLE');
	table.appendChild(tableRow);

	if (filterList.length > 1) {
		var lastCell = tableRow.lastChild;
		lastCell.replaceChild(createXMarkAfter(), lastCell.firstChild);

		for (var i = 1; i < filterList.length; ++i)
			table.appendChild(createFilterRow(i, filterList[i]));
	}

	applyFilters();
	return table;
}
function createFilterDiv()
{
	for (var i = 0; i < filterOptions.length; ++i)
		filterIndex[filterOptions[i].name] = i;

	var option = filterOptions[filterIndex['threshold']];
	option.noChangeValue = null;

	option = filterOptions[filterIndex['polar']];
	option.ui = polarUI;
	option.noChangeValue = null;

	option = filterOptions[filterIndex['depolar']];
	option.ui = polarUI;
	option.noChangeValue = null;

	option = filterOptions[filterIndex['convolve']];
	option.ui = convolveUI;

	for (option of ['blur', 'blur-x', 'blur-y', 'd-blur-x', 'd-blur-y'])
		filterOptions[filterIndex[option]].ui = blurUI;

	var table = createFiltersFromQueryString();
	if (!table) {
		var tableRow = createFilterRow(0);
		table = document.createElement('TABLE');
		table.appendChild(tableRow);
	}

	var filterDiv = document.getElementById('filterDiv');
	filterDiv.insertBefore(table, filterDiv.firstChild);
}
function toggleShowFilters(event)
{
	event.preventDefault();

	var filterDiv = document.getElementById('filterDiv');
	var toggleFiltersLink = document.getElementById('toggleFiltersLink').firstChild;

	if (filterDiv.style.display === 'none') {
		filterDiv.style.display = 'block';
		toggleFiltersLink.nodeValue = 'Hide Filters';
	} else {
		filterDiv.style.display = 'none';
		toggleFiltersLink.nodeValue = 'Show Filters';
	}
}
function browseFiles(event)
{
	event.preventDefault();
	document.getElementById("fileBrowser").click();
}
function loadFiles()
{
	var files = document.getElementById("fileBrowser").files;

	var newImageNames = [];
	var newImageFiles = [];

	for (var i = 0; i < files.length; ++i)
	{
		var typePrefix = files[i].type.substr(0, 6);
		if (typePrefix === 'image/' || typePrefix === 'video/')
		{
			newImageNames.push(files[i].name);
			newImageFiles.push(files[i]);
		}
	}

	if (newImageNames.length === 0) return;

	imageNames = newImageNames;
	imageFiles = newImageFiles;

	var fileNameField = document.getElementById("fileNameField");
	fileNameField.options.length = 0;
	fileNameField.selectedIndex = -1;

	loadImage();
}
function copyToClipboard()
{
	if (!copySupported) return;

	copySupported = document.execCommand("copy");

	if (copySupported) return;

	for (var id of ["copyURL", "copyCSS", "copySVG", "copyCropGeometry"])
		document.getElementById(id).firstChild.nodeValue = "Select";
}
function copyNode(event, elementId)
{
	event.preventDefault();
	window.getSelection().selectAllChildren(document.getElementById(elementId));
	copyToClipboard();
}
function copyURL(event)
{
	copyNode(event, "urlCode");
}
function copyCSS(event)
{
	copyNode(event, "cssCode");
}
function copySVG(event)
{
	copyNode(event, "svgCode");
}
function copyCropGeometry(event)
{
	event.preventDefault();
	document.getElementById("cropGeometry").select();
	copyToClipboard();
}
function manageUserSpaceFilters()
{
	if (divWidth === oldDivWidth && divHeight === oldDivHeight) {
		if (!svgMode) updateUserSpaceFilters();
		return;
	}

	oldDivWidth = divWidth;
	oldDivHeight = divHeight;
	resetUserSpaceFilters();

	var updateFilters = false;
	for (var filter of filters)
	{
		var name = filter.option.name;
		if (name === 'polar' || name === 'depolar') {
			filter.manage = true;
			updateFilters = true;
		}
	}
	if (updateFilters)
		applyFilters();
}
function documentKeyDown(event)
{
	if (event.target instanceof HTMLInputElement ||
		event.target instanceof HTMLSelectElement) return true;
	if (document.onmousemove) return true;

	var key = event.key || event.keyIdentifier;

	if (key === 'g' || key === 'U+0047') {
		showCropGeometry = !showCropGeometry;
		document.getElementById("cropGeometryDiv").style.display = showCropGeometry ? 'block' : 'none';
	} else if (key === 'o' || key === 'U+004F') {
		document.getElementById("overlayCanvasLink").click();
	} else if (event.shiftKey) {
		if (key === 'ArrowLeft' || key === 'Left')
			rotatePhoto(270);
		else if (key === 'ArrowRight' || key === 'Right')
			rotatePhoto(90);
		else if (key === 'ArrowDown' || key === 'Down')
			rotatePhoto(180);
		else if (key === 'ArrowUp' || key === 'Up')
			rotatePhoto(180);
		else
			return true;
		if (document.getElementById("canvas").style.display === 'block')
			drawCanvas();
	} else if (key === ' ' || key === 'U+0020') {
		if (photo instanceof HTMLVideoElement) {
			if (photo.paused)
				photo.play();
			else
				photo.pause();
		}
	} else
		return true;

	event.preventDefault();
	event.stopPropagation();
	return false;
}
function showAbout(event)
{
	event.preventDefault();
	var aboutDiv = document.getElementById("aboutDiv");
	aboutDiv.style.display = "block";
	centerElement(aboutDiv);
}
function hideAbout()
{
	document.getElementById("aboutDiv").style.display = "none";
}
function disableCropElements(disable)
{
	var elementIds = [
		"cropWidthField",
		"cropHeightField",
		"cropXField",
		"cropYField",
		"cropButton",
		"undoButton",
		"rotateLeftButton",
		"rotateRightButton",
		"rotate180Button",
		"inverseAspectRatioCheckbox",
		"fileNameField"
	];

	for (var id of elementIds)
		document.getElementById(id).disabled = disable;
}
function bodyLoaded()
{
	if (typeof imagePath !== "string")
		imagePath = "";
	if (!Array.isArray(imageNames) || imageNames.length === 0)
		imageNames = undefined;

	disableCropElements(true);

	var photoDiv = document.getElementById("photoDiv");
	photo = photoDiv.firstChild;

	cropper = document.getElementById("cropper");
	cropper.style.left = (photoDiv.offsetLeft + 4) + 'px';
	cropper.style.top = (photoDiv.offsetTop + 4) + 'px';

	controlDiv = document.getElementById("controlDiv");
	controlDiv.onmousedown = startControlDivDrag;

	// Hack for Mozilla to clear any previously selected files
	document.getElementById("fileBrowser").value = "";
	document.getElementById("cropGeometry").value = "";

	if (showCropGeometry)
		document.getElementById("cropGeometryDiv").style.display = "block";

	downloadLink = document.getElementById("downloadLink");
	downloadLink.addEventListener("click", saveImage, false);

	parseQueryString();
	createFilterDiv();
	document.getElementById("toggleFiltersLink").addEventListener("click", toggleShowFilters, false);
	document.getElementById("showFilterCode").addEventListener("click", showFilterCode, false);
	document.getElementById("copyURL").addEventListener("click", copyURL, false);
	document.getElementById("copyCSS").addEventListener("click", copyCSS, false);
	document.getElementById("copySVG").addEventListener("click", copySVG, false);
	document.getElementById("fileBrowserLink").addEventListener("click", browseFiles, false);
	document.getElementById("copyCropGeometry").addEventListener("click", copyCropGeometry, false);
	document.getElementById("aboutLink").addEventListener("click", showAbout, false);
	document.getElementById("overlayCanvasLink").addEventListener("click", overlayCanvas, false);
	document.getElementById("modeSelect").addEventListener("change", changeMode, false);
	document.addEventListener("keydown", documentKeyDown, false);
	changeMode();
	loadImage();
}
</script>
</head>
<body onload="bodyLoaded()">

<div id="photoDiv"><img /></div>
<div id="cropper">
<div id="resizeNW"></div>
<div id="resizeNE"></div>
<div id="resizeSW"></div>
<div id="resizeSE"></div>
</div>
<a href="#" id="aboutLink">About</a>
<a href="#" id="overlayCanvasLink">Overlay Canvas</a>

<div id="filterCodeDiv">
URL: <a href="#" id="copyURL">Copy</a><br><code id="urlCode"></code>
CSS: <a href="#" id="copyCSS">Copy</a><br><code id="cssCode"></code>
SVG: <a href="#" id="copySVG">Copy</a><br><code id="svgCode"></code>
<input type="button" value="Close" onclick="hideFilterCode()" />
</div>
<div id="controlDiv">
Crop Area (Width x Height + X + Y): <input
	type="text" id="cropWidthField" size="4" value="" onchange="changeCropWidth()" />x<input
	type="text" id="cropHeightField" size="4" value="" onchange="changeCropHeight()" />+<input
	type="text" id="cropXField" size="4" value="" onchange="changeCropX()" />+<input
	type="text" id="cropYField" size="4" value="" onchange="changeCropY()" />
<br>
<input type="button" value="Crop" id="cropButton" onclick="crop()" />
<input type="button" value="Undo" id="undoButton" onclick="undo()" />
<input type="button" value="Rotate Left" id="rotateLeftButton" onclick="rotatePhoto(270)" />
<input type="button" value="Rotate Right" id="rotateRightButton" onclick="rotatePhoto(90)" />
<input type="button" value="Rotate 180" id="rotate180Button" onclick="rotatePhoto(180)" />
<br>
Display Width x Height: <input
	type="text" readonly id="divWidth" size="4" value="" />x<input
	type="text" readonly id="divHeight" size="4" value="" />
<span id="aspectRatio">(:)</span>
<br>
<input type="checkbox" id="inverseAspectRatioCheckbox" onclick="toggleInverseAspectRatio()" />
Crop Inverse Aspect Ratio
&nbsp;&nbsp;<a href="#" id="toggleFiltersLink">Hide Filters</a>
(<a href="#" id="showFilterCode">Code</a>)
&nbsp;&nbsp;<a href="#" id="fileBrowserLink">Browse Files</a>
<br>
<input type="file" id="fileBrowser" accept="image/*,video/*" multiple onchange="loadFiles()" />
<select id="fileNameField" onchange="loadImage()"></select>
<input type="button" id="prevButton" value="Previous" onclick="prevImage()" />
<input type="button" id="nextButton" value="Next" onclick="nextImage()" />
<a download href="#" id="downloadLink">Save</a>
<br>
<div id="cropGeometryDiv"><input type="text" id="cropGeometry" size="44" value="" readonly />
<a href="#" id="copyCropGeometry">Copy</a></div>
<div id="filterDiv"><div><span style="margin: 2px;">Mode:</span><select id="modeSelect">
<option value="3">SVG &lt;image&gt;</option>
<option value="0">HTML &lt;img&gt;</option>
<option value="1">HTML &lt;img&gt; + 1 SVG &lt;filter&gt;</option>
<option value="4">HTML &lt;video&gt;</option>
<option value="5">HTML &lt;video&gt; + 1 SVG &lt;filter&gt;</option></select></div></div>
</div>
<div id="convolveInfoDiv">
<b>Convolution Kernels</b>
<table id="kernelTable">
<tr>
<td><a href="https://en.wikipedia.org/wiki/Sobel_operator">Sobel</a> X
<table class="kernel">
<tr><td> </td><td>-1  0  1</td><td> </td></tr>
<tr><td> </td><td>-2  0  2</td><td> </td></tr>
<tr><td> </td><td>-1  0  1</td><td> </td></tr>
</table></td>
<td><a href="https://en.wikipedia.org/wiki/Sobel_operator">Sobel</a> Y
<table class="kernel">
<tr><td> </td><td>-1 -2 -1</td><td> </td></tr>
<tr><td> </td><td> 0  0  0</td><td> </td></tr>
<tr><td> </td><td> 1  2  1</td><td> </td></tr>
</table></td>
<td><a href="https://en.wikipedia.org/wiki/Prewitt_operator">Prewitt</a> X
<table class="kernel">
<tr><td> </td><td>-1  0  1</td><td> </td></tr>
<tr><td> </td><td>-1  0  1</td><td> </td></tr>
<tr><td> </td><td>-1  0  1</td><td> </td></tr>
</table></td>
<td><a href="https://en.wikipedia.org/wiki/Prewitt_operator">Prewitt</a> Y
<table class="kernel">
<tr><td> </td><td>-1 -1 -1</td><td> </td></tr>
<tr><td> </td><td> 0  0  0</td><td> </td></tr>
<tr><td> </td><td> 1  1  1</td><td> </td></tr>
</table></td>
</tr>
<tr>
<td>Sharpen
<table class="kernel">
<tr><td> </td><td> 0 -1  0</td><td> </td></tr>
<tr><td> </td><td>-1  5 -1</td><td> </td></tr>
<tr><td> </td><td> 0 -1  0</td><td> </td></tr>
</table></td>
<td>Edge Detect 1
<table class="kernel">
<tr><td> </td><td>-1 -1 -1</td><td> </td></tr>
<tr><td> </td><td>-1  8 -1</td><td> </td></tr>
<tr><td> </td><td>-1 -1 -1</td><td> </td></tr>
</table></td>
<td>Edge Detect 2
<table class="kernel">
<tr><td> </td><td> 0  1  0</td><td> </td></tr>
<tr><td> </td><td> 1 -4  1</td><td> </td></tr>
<tr><td> </td><td> 0  1  0</td><td> </td></tr>
</table></td>
<td>Edge Detect 3
<table class="kernel">
<tr><td> </td><td> 1   -1   1</td><td> </td></tr>
<tr><td> </td><td>-1 -0.01 -1</td><td> </td></tr>
<tr><td> </td><td> 1   -1   1</td><td> </td></tr>
</table></td>
</tr>
<tr>
<td>Emboss 1
<table class="kernel">
<tr><td> </td><td> 1  0  0</td><td> </td></tr>
<tr><td> </td><td> 0  0  0</td><td> </td></tr>
<tr><td> </td><td> 0  0 -1</td><td> </td></tr>
</table></td>
<td>Emboss 2
<table class="kernel">
<tr><td> </td><td>-2 -1  0</td><td> </td></tr>
<tr><td> </td><td>-1  1  1</td><td> </td></tr>
<tr><td> </td><td> 0  1  2</td><td> </td></tr>
</table></td>
<td>Emboss 3
<table class="kernel">
<tr><td> </td><td>-2 -2  0</td><td> </td></tr>
<tr><td> </td><td>-2  6  0</td><td> </td></tr>
<tr><td> </td><td> 0  0  0</td><td> </td></tr>
</table></td>
<td></td>
</tr>
</table>
<input type="button" value="Close" onclick="convolveUI.hideInfo()" />
</div>
<canvas id="canvas"></canvas>
<div id="aboutDiv">
<div style="text-align: center;">
<b>PIE (Pius' Image Editor)</b>
[<a href="https://github.com/nightjuggler/pig">GitHub</a>]
</div><br>
<div style="text-align: justify;">
Note that <span class="action">Overlay Canvas</span> and <span class="action">Save</span> will
only work if the image you're viewing is either served from the same origin as this page or if
the image was selected via <span class="action">Browse Files</span>. <span class="action">Overlay
Canvas</span> and <span class="action">Save</span> will draw the image into an HTML canvas, get
the image data from the canvas (which the browser will not allow for cross-origin images), apply
the filter operations to the image data, and draw the image data back to the canvas.
<br><br>
For best results in Chrome, use mode <span class="action">HTML &lt;img&gt; + 1 SVG &lt;filter&gt;</span>.
For best results in Safari, use mode <span class="action">SVG &lt;image&gt;</span>.
All modes seem to work equally well in Firefox.
</div>
<div style="text-align: center;"><input type="button" value="Close" onclick="hideAbout()" /></div>
</div>
<div id="progressDiv"><span id="progressText">Loading</span><div id="spinDisc"></div></div>
<div id="failedDiv">Failed to load<br><input type="button" value="Close" onclick="hideFailed()" /></div>
<svg id="svgRoot" width="0" height="0" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><defs></defs></svg>
</body>
</html>
